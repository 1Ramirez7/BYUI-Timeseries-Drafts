{
  "hash": "0d80652be3339639150a29967ea3be02",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Moving Average (MA) Models\"\nsubtitle: \"Chapter 6: Lesson 1\"\nformat: html\neditor: source\nsidebar: false\n---\n\n\n\n```{=html}\n<script type=\"text/javascript\">\n function showhide(id) {\n    var e = document.getElementById(id);\n    e.style.display = (e.style.display == 'block') ? 'none' : 'block';\n }\n \n function openTab(evt, tabName) {\n    var i, tabcontent, tablinks;\n    tabcontent = document.getElementsByClassName(\"tabcontent\");\n    for (i = 0; i < tabcontent.length; i++) {\n        tabcontent[i].style.display = \"none\";\n    }\n    tablinks = document.getElementsByClassName(\"tablinks\");\n    for (i = 0; i < tablinks.length; i++) {\n        tablinks[i].className = tablinks[i].className.replace(\" active\", \"\");\n    }\n    document.getElementById(tabName).style.display = \"block\";\n    evt.currentTarget.className += \" active\";\n }    \n</script>\n```\n\n\n\n\n\n## Learning Outcomes\n\n\n<details>\n\n<summary>Characterize the properties of moving average (MA) models</summary>\n-   Define a moving average (MA) process \n-   Write an MA(q) model in terms of the backward shift operator\n-   State the mean and variance of an MA(q) process\n-   Explain the autocorrelation function of an MA(q) process\n-   Define an invertible MA process\n\n</details>\n\n<details>\n\n<summary>Fit time series models to data and interpret fitted parameters</summary>\n-   Determine an appropriate MA(q) model to fit to a time series based on the ACF plot\n-   Fit an MA(q) model to data in R using the arima() function\n-   Assess model fit by examining residual diagnostic plots\n-   Interpret the fitted MA coefficients\n\n</details>\n\n\n\n\n\n\n## Preparation\n\n-   Read Sections 6.1-6.4\n\n\n\n## Learning Journal Exchange (10 min)\n\n-   Review another student's journal\n\n-   What would you add to your learning journal after reading another student's?\n\n-   What would you recommend the other student add to their learning journal?\n\n-   Sign the Learning Journal review sheet for your peer\n\n\n\n## Class Activity: Introduction to Moving Average (MA) Models (15 min)\n\n### Stationary Processes\n\nIn previous chapters, we have explored how to identify and remove the trend and seasonal components of a time series. After the trend and seasonal component have been properly removed, the residual should be stationary. However, these residual components may still contain autocorrelation. \n\nIn this chapter, we will explore stationary models that are appropriate when there are no obvious trends or seasonal elements. Combining the fitted stationary model with the estimated trend and seasonal components can improve our ability to make forecasts. We will build on the autoregressive (AR) models we learned in Chapter 4.\n\n### Strictly Stationary Series\n\nFirst, we define a strictly stationary series.\n\n::: {.callout-note icon=false title=\"Definition of Strict Stationarity\"}\n\nA time series model $\\{x_t\\}$ is said to be **strictly stationary** if the joint distribution of the random variables \n$x_{t_1}, x_{t_2}, \\ldots, x_{t_n}$ is the same as the joint distribution of \n$x_{t_1+m}, x_{t_2+m}, \\ldots, x_{t_n+m}$ for all $t_1, t_2, \\ldots, t_n$ and $m$, so that the distribution of the values in the time series is the same after an arbitrary time shift.\n\n:::\n\nIf a time series is strictly stationary, then its mean and variance are constant in time. Hence, the autocovariance $cov(x_t, x_s)$ depends only on the lag, $k = | t - s |$. We can therefore denote the covariance function as $\\gamma(k) = cov(x_t, x_{t+k})$.\n\n**Note:** It is possible that a series could have a constant mean and variance in time and the autocovariance depends only on the lag, but the series is not strictly stationary. This is called **second-order stationary**.\n\nWe will focus on the second-order properties of the time series, even though all the series we will explore in this chapter are strictly stationary.\n\n**Note:** if a white noise process is Gaussian, the stochastic process is completely determined by the mean and covariance structure. This is similar to how a (univariate or multivariate) normal distribution is completely specified by the mean and variance-covariance matrix.\n\nThe concept of stationarity is a property of time series models. When we use certain models, we are assuming stationarity. Before we apply these models, it is important to check for stationarity in the time series. In other words, we check to see if there is evidence of a trend or seasonality and if so, we remove these components.\nWe can use methods such as decomposition, Holt-Winters, or regression to remove the trend and seasonality. Hence, it is typically reasonable to consider the residual series as a stationary series.\nTypically the models in this chapter are applied to the residual series from a regression or similar analysis.\n\n\n### Moving Average (MA) Models\n\nRecall in [Chapter 4, Lesson 3](https://byuistats.github.io/timeseries/chapter_4_lesson_3.html#ARdefinition), we learned the definition of an AR model:\n\n::: {.callout-note icon=false title=\"Definition of an Autoregressive (AR) Model\"}\n\nThe time series $\\{x_t\\}$ is an **autoregressive process of order $p$**, denoted as $AR(p)$, if\n$$\n  x_t = \\alpha_1 x_{t-1} + \\alpha_2 x_{t-2} + \\alpha_3 x_{t-3} + \\cdots + \\alpha_{p-1} x_{t-(p-1)} + \\alpha_p x_{t-p} + w_t ~~~~~~~~~~~~~~~~~~~~~~~ (4.15)\n$$\n\nwhere $\\{w_t\\}$ is white noise and the $\\alpha_i$ are the model parameters with $\\alpha_p \\ne 0$.\n\n:::\n\nThe $AR(p)$ model can be expressed in terms of the backward shift operator:\n$$\n   \\left( 1 - \\alpha_1 \\mathbf{B} - \\alpha_2 \\mathbf{B}^2 - \\cdots - \\alpha_p \\mathbf{B}^p \\right) x_t = w_t\n$$\n\nNow, we consider a different, but related model, the moving average (MA) model\n\n::: {.callout-note icon=false title=\"Definition of a Moving Average (MA) Model\"}\n\nWe say that a time series $\\{x_t\\}$ is a **moving average process of order $q$**, denoted as $MA(q)$, if each term in the time series is a linear combination of the current white noise term and the $q$ most recent past white noise terms. \n\nIt is given as:\n$$\n  x_t = w_t + \\beta_1 w_{t-1} + \\beta_2 w_{t-2} + \\beta_3 w_{t-3} + \\cdots + \\beta_{q-1} w_{t-(q-1)} + \\beta_q w_{t-q} ~~~~~~~~~~~~~~~~~~~~~~~ (6.1)\n$$\n\nwhere $\\{w_t\\}$ is white noise with zero mean and variance $\\sigma_w^2$, and the $\\beta_i$ are the model parameters with $\\beta_q \\ne 0$.\n\n:::\n\n\n In the check your understanding below, \n The students write the MA model in terms \n of the backward shift operator. \n\n\n\n Check your Understanding \n\n::: {.callout-tip icon=false title=\"Check Your Understanding\"}\n\n-   Write Equation (6.1) in terms of the backward shift operator. Your answer will be of the form:\n\n$$\n  x_t \n    = (\\text{some}~q^{th}~\\text{degree polynomial in}~\\mathbf{B}) w_t\n    = \\phi_q(\\mathbf{B}) w_t\n$$\n\n:::\n\n\n::: {.callout-caution icon=false title=\"Note\"}\n\nAn $MA(q)$ process is comprised of a finite summation of stationary white noise terms. Hence, an $MA(q)$ process will be stationary with a time-invariante mean and autocovariance.\n\nThe mean and variance of $\\{x_t\\}$ are easily derived. The mean must be zero, because each term is a sum of scaled white noise terms with mean zero.\n\nThe variance of an $MA(q)$ process is ${ \\sigma_w^2 \\left( 1 + \\beta_1^2 + \\beta_2^2 + \\beta_3^2 + \\cdots + \\beta_{q-1}^2 + \\beta_q^2 \\right) }$. This can be seen, because the white noise terms are independent with the same variance.\n\nSo, the autocorrelation function is\n\n$$\n  \\rho(k) =\n  cor(x_t, x_{t+k}) =\n    \\begin{cases}\n      1, & k=0 \\\\\n      ~\\\\\n      \\dfrac{ \\sum\\limits_{i=0}^{q-k} \\beta_i \\beta_{i+k} }{ \\sum\\limits_{i=0}^q \\beta_i^2 }, & k = 1, 2, \\ldots, q \\\\\n      ~\\\\\n      0, & k > q\n    \\end{cases}\n$$\nwhere $\\beta_0 = 1$.\n\nNote that the autocorrelation function is zero if $k>q$, because $x_t$ and $x_{t+k}$ would be independent weighted summations of white noise processes and hence the covariance between them would be zero.\n\n:::\n\nWe now define an invertible $MA$ process.\n\n::: {.callout-note icon=false title=\"Definition of an Invertible $MA$ Process\"}\n\nAn $MA$ process is said to be **invertible** if it can be expressed as a stationary autoregressive process (of infinite order) with no error term.\n\n:::\n\n#### Example of an Invertible MA Process\n\nRecall that \n$$\n  (1-x)(1 + x + x^2 + x^3 + \\cdots) = 1\n$$\n\nor, \n\n$$\n  (1-x)^{-1} = (1 + x + x^2 + x^3 + \\cdots)\n$$\nif $|x|<1$.\n\nNow, note that the $MA$ process \n\n$$\n  x_t = \\left( 1 - \\beta \\mathbf{B} \\right) w_t\n$$\n\ncan be written as:\n\n\\begin{align*}\n  \\left( 1 - \\beta \\mathbf{B} \\right)^{-1} x_t &= w_t \\\\\n  \\left( 1 + \\beta \\mathbf{B} + \\beta^2 \\mathbf{B}^2 + \\beta^3 \\mathbf{B}^3 + \\cdots \\right) x_t &= w_t \\\\\n  x_t + \\beta x_{t-1} + \\beta^2 x_{t-2} + \\beta^3 x_{t-3} + \\cdots &= w_t \\\\\n  x_t &= \\left( -\\beta x_{t-1} - \\beta^2 x_{t-2} - \\beta^3 x_{t-3} - \\cdots \\right) + w_t\n\\end{align*}\n\nassuming that $|\\beta|<1$. Note that this series will not converge unless $|\\beta|<1$. \n\nWe have just shown that the $MA$ process \n$$\n  x_t = \\left( 1 - \\beta \\mathbf{B} \\right) w_t\n$$\nis invertible.\n\n\n::: {.callout-note icon=false title=\"Theorem: Invertibility of an $MA(q)$ Process\"}\n\nThe $MA(q)$ process \n$$\n  x_t = \\phi_q(\\mathbf{B}) w_t\n$$\nwill be invertible if the solutions to the equation\n$$\n  \\phi_q(\\mathbf{B}) = 0\n$$\nare all greater than 1 in absolute value.\n\n:::\n\nFittedModelWillBeInvertible - Does this remind you of the test for the stationarity of an $AR(p)$ model?\n\nNote that the autocovariance function (acvf) will identify a unique $MA(q)$ process only if the process is invertible. Fortunately, the algorithm R uses to estimate an $MA(q)$ process always leads to an invertible model.\n\n\n## Class Activity: Simulating an $MA(q)$ Model (5 min)\n\nThe textbook gives a simulation of an $MA(3)$ process:\n\n$$\n  x_t = w_t + \\beta_1 w_{t-1} + \\beta_2 w_{t-2} + \\beta_3 w_{t-3}\n$$\n\nwhere $\\beta_1 = 0.7$, $\\beta_1 = 0.5$, and $\\beta_3 = 0.2$. This shiny app allows you to simulate from this process.\n\nshinny content \n\n\n The code below is replaced by the shiny app above. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\npacman::p_load(\"tsibble\", \"fable\", \"feasts\", \n   \"tsibbledata\", \"fable.prophet\", \"tidyverse\", \n   \"patchwork\", \"slider\", \"urca\") \n\n# define the parameters of the simulation \nbeta1 <- 0.7 \nbeta2 <- 0.5 \nbeta3 <- 0.2 \n\n# function to compute the autocorrelation \nrho <- function(k, beta) { \n q <- length(beta) - 1 \n if (k > q) ACF <- 0 else { \n   s1 <- 0; s2 <- 0 \n   for (i in 1:(q-k+1)) s1 <- s1 + beta[i] * beta[i+k] \n   for (i in 1:(q+1)) s2 <- s2 + beta[i]^2 \n   ACF <- s1 / s2} \n ACF \n} \n\n# create the tibble \nacf_dat <- tibble( \n order = 0:10, \n betas = list(c(1, beta1, beta2, beta3)), \n rho.k = map2_dbl(order, betas, ~rho(.x, .y))) \n\n# generate the autocorrelation plot \nacf_dat |> \n ggplot(aes(x = order, y = rho.k)) + \n geom_hline(yintercept = 0, color = \"darkgrey\") + \n geom_point() + \n labs(y = expression(rho[k]), x = \"lag k\") + \n   labs( \n     x = \"Time\", \n     y = \"ACF\", \n     title = \"Theoretical ACF for the Simulated MA(3) Process\" \n   ) + \n   theme_bw() + \n   theme( \n     plot.title = element_text(hjust = 0.5) \n   ) \n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\n Now, we simulate data from this process. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nset.seed(1234) \ndat <- tibble( \n w = rnorm(1000), \n betas = list(c(beta1, beta2, beta3))) |> \n mutate( \n   w_lag = slide(w, ~.x, .before = 3, .after = -1), \n   w_lag = map(w_lag, ~rev(.x)), \n   t = 1:n()) |> \n slice(-c(1:3)) |> \n mutate( \n   lag_betas = map2_dbl( \n     w_lag, \n     betas, \n     \\(.x, .y) sum(.x *.y)), \n   x = w + lag_betas) |> \n tsibble::as_tsibble(index = t) \nautoplot(dat, .var = x) \n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\n Here is the acf function computed from the simulated data. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndat |> \n ACF(y = x) |> \n autoplot() \n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n Check Your Understanding \n\n::: {.callout-tip icon=false title=\"Check Your Understanding\"}\n\nUse the simulation above to do the following:\n\n-   Generate the theoretical acf plot for the $MA(3)$ model\n$$\n  x_t = w_t - 0.7 w_{t-1} + 0.5 w_{t-2} - 0.2 w_{t-3}\n$$\n-   How does the value of the $\\beta$'s affect the acf?\n-   Simulate 1000 observations from this $MA(3)$ process.\n    -   Give the time plot of the simulated data\n    -   Plot the acf of the simulated data.\n-   Compare the acf from the simulated data with the theoretical acf.\n  \n:::\n\n\n## Class Activity: Identifying AR and MA Models from the ACF and PACF (5 min)\n\n#### AR Process\n\nRecall that on page 81, the textbook states that in general, the partial autocorrelation at lag $k$ is the $k^{th}$ coefficient of a fitted $AR(k)$ model.\nThis implies that if the underlying process is $AR(p)$, then all the coefficients $\\alpha_k$ will equal 0 whenever $k>p$. So, an $AR(p)$ process will result in partial correlations that are zero after lag $p$. So, we can look at the correlogram of partial autocorrelations to determine the order of an appropriate $AR$ process to model a time series.\n\n#### MA Process\n\nSimilarly, for an $MA(q)$ process, the coefficients $\\beta_k$ will equal 0 whenever $k > q$. Hence, an $MA(q)$ process will demonstrate autocorrelations that are 0 after lag $q$. So, considering the correlogram of autocorrelations, we can assess if an $MA(q)$ model would be appropriate. \n\nBless their hearts, the textbook authors give a bad example in Section 6.4.2. They even state that it is \"not a realistic realisation.\" MA processes naturally arise in ratios of observed data. Multi-period asset returns (i.e. ratios of some previous term's value) tend to follow an MA process.\n\nFor example, if there are 252 trading days in a year, then the daily series of year-over-year returns (this year's value divided by last year's value) follows an $MA(252-1)$ process. If we are comparing values observed to those from one week ago, we would have an $MA(7-1)$ process.\n\n#### Comparison \n::: {.callout-note icon=false title=\"ACF and PACF of an $AR(p)$ Process\"}\n\nWe can use the pacf and acf plots to assess if an $AR(p)$ or $MA(q)$ model is appropriate. \nFor an $AR(p)$ or $MA(q)$ process, we observe the following:\n\n<center>\n\n|      | AR(p)                  | MA(q)                  |\n|------|------------------------|------------------------|\n| ACF  | Tails off              | Cuts off after lag $q$ |\n| PACF | Cuts off after lag $p$ | Tails off              |\n\n</center>\n\n https://people.cs.pitt.edu/~milos/courses/cs3750/lectures/class16.pdf \n\n |      | AR(p)                  | MA(q)                  | ARMA(p,q)                | \n |------|------------------------|------------------------|--------------------------| \n | ACF  | Tails off              | Cuts off after lag $q$ | Tails off                | \n | PACF | Cuts off after lag $p$ | Tails off              | Tails off                | \n\n:::\n\n\n## Class Activity: Fitting an $MA(q)$ Model to GDP Year-Over-Year Ratios (5 min)\n\nTo fit an $MA(q)$ model, we look at the acf to determine if it cuts off after $q$ lags.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# gdp_ts <- rio::import(\"https://byuistats.github.io/timeseries/data/gdp_fred.csv\") |>\ngdp_ts <- rio::import(\"data/gdp_fred.csv\") |>\n#  select(-comments) |>\n  mutate(year_over_year = gdp_millions / lag(gdp_millions, 4)) |>\n  mutate(quarter = yearquarter(mdy(quarter))) |>\n  filter(quarter >= yearquarter(my(\"Jan 1990\")) & quarter < yearquarter(my(\"Jan 2025\"))) |>\n  na.omit() |>\n  mutate(t = 1:n()) |>\n  mutate(std_t = (t - mean(t)) / sd(t)) |>\n  as_tsibble(index = quarter)\n\ngdp_ts |>\n  autoplot(.vars = gdp_millions) +\n    labs(\n      x = \"Quarter\",\n      y = \"GDP (Millions of $US)\",\n      title = \"U.S. Gross Domestic Product (GDP) in Millions of Dollars\"\n    ) +\n    theme_minimal() +\n    theme(plot.title = element_text(hjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngdp_ts |>\n  autoplot(.vars = year_over_year) +\n  stat_smooth(method = \"lm\", \n              formula = y ~ x, \n              geom = \"smooth\",\n              se = FALSE,\n              color = \"#E69F00\",\n              linetype = \"dotted\") +\n    labs(\n      x = \"Quarter\",\n      y = \"Ratio\",\n      title = \"Year-Over-Year Change in U.S. GDP\"\n    ) +\n    theme_minimal() +\n    theme(plot.title = element_text(hjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngdp_ts |>\n  select(year_over_year) |>\n  acf()\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-5-3.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngdp_ts |>\n  select(year_over_year) |>\n  pacf()\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-5-4.png){width=672}\n:::\n:::\n\n\n\n\n Check Your Understanding \n\n::: {.callout-tip icon=false title=\"Check Your Understanding\"}\n\n-   What process would you use to model the year-over-year GDP ratios?\n-   Modify the code below to implement your model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdp_ma <- gdp_ts |>\n  model(arima = ARIMA(year_over_year ~ 1 + pdq(0,0,1) + PDQ(0, 0, 0)))\n\ntidy(gdp_ma)\n\ngdp_ma |>\n  residuals() |>\n  ACF() |>\n  autoplot()\n```\n:::\n\n\n\n-   What are the values of the model coefficients?\n-   Based on the acf of the residuals, is the MA model you identified a good fit to the data?\n\n:::\n\n\n\n\n## Small-Group Activity: Fitting an $MA(q)$ Model to the Trade Data (15 min)\n\n\n#### Vessels Cleared in Foreign Trade for United States\n\nIn the homework for Chapter 1 Lesson 5, you explored data on the thousands of net tons cleared in foreign trade for the United States each month from January 1902 to December 1940. The code below computes the year-over-year change in the amount of cargo cleared for trade. This is stored in the variable `ratio`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nvessels_ts <- rio::import(\"https://byuistats.github.io/timeseries/data/Vessels_Trade_US.csv\") |>\n  # filter(-comments) |>\n  mutate(\n    date = yearmonth(dmy(date)),\n    ratio = vessels / lag(vessels, 12)\n  ) |>\n  na.omit() |>\n  as_tsibble(index = date)\n\nvessels_ts |>\n  autoplot(.vars = ratio) +\n    labs(\n      x = \"Month\",\n      y = \"Ratio\",\n      title = \"Year-Over-Year Change in Net Tons on Vessels Cleared for Trade\"\n    ) +\n    theme_minimal() +\n    theme(plot.title = element_text(hjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n Check Your Understanding \n\n::: {.callout-tip icon=false title=\"Check Your Understanding\"}\n\nPractice applying an $MA(q)$ model using the year-over-year amounts.\n\n-   Determine which MA model is most appropriate for these data.\n-   Fit the model you deem most appropriate.\n-   Assess the appropriateness of applying your model to the data.\n\n:::\n\n\n\n\n\n\n## Homework Preview (5 min)\n\n-   Review upcoming homework assignment\n-   Clarify questions\n\n\n\n\n\n\n\nsolution 1\n\n  \n\\begin{align*}\n  x_t \n    &= w_t + \\beta_1 w_{t-1} + \\beta_2 w_{t-2} + \\beta_3 w_{t-3} + \\cdots + \\beta_{q-1} w_{t-(q-1)} + \\beta_q w_{t-q} \\\\\n    &= w_t + \\beta_1 \\mathbf{B} w_t + \\beta_2 \\mathbf{B}^2 w_t + \\beta_3 \\mathbf{B}^3 w_t + \\cdots + \\beta_{q-1} \\mathbf{B}^{q-1} w_t + \\beta_q \\mathbf{B}^{q} w_t \\\\\n    &= \\left( 1 + \\beta_1 \\mathbf{B} + \\beta_2 \\mathbf{B}^2  + \\beta_3 \\mathbf{B}^3  + \\cdots + \\beta_{q-1} \\mathbf{B}^{q-1}  + \\beta_q \\mathbf{B}^{q} \\right) w_t \\\\\n    &= \\phi_q(\\mathbf{B}) w_t\n\\end{align*}\n\n\n\n\n\nsolution 2\n  \n\n\nSet the values of the parameters $n$, $\\beta_1$, $\\beta_2$, and $\\beta_3$ in the simulation to the following:\n$$\nn = 1000, ~~~~~~~~~~~\n\\beta_1 = -0.7, ~~~~~~~~~~~\n\\beta_2 = 0.5, ~~~~~~~~~~~\n\\beta_3 = -0.2\n$$\n\n\n\n\n\n\n\nsolution 3\n  \n\n Check Your Understanding \n\n\n-   What process would you use to model the year-over-year GDP ratios?\n\nBased on the acf, an $MA(3)$ model seems most appropriate.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngdp_ts |>\n  select(year_over_year) |>\n  acf()\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngdp_ts |>\n  select(year_over_year) |>\n  pacf()\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n-   Modify the code below to implement your model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngdp_ma <- gdp_ts |>\n  # Changed 1 to a 3 on the next line\n  model(arima = ARIMA(year_over_year ~ 1 + pdq(0,0,3) + PDQ(0, 0, 0))) \n```\n:::\n\n\n\n-   What are the values of the model coefficients?\n\nThe values of the coefficients are given in the table below:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ntidy(gdp_ma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 6\n  .model term     estimate std.error statistic   p.value\n  <chr>  <chr>       <dbl>     <dbl>     <dbl>     <dbl>\n1 arima  ma1         0.978   0.0341       28.7 1.32e- 59\n2 arima  ma2         1.01    0.0413       24.5 8.75e- 52\n3 arima  ma3         0.965   0.0389       24.8 2.32e- 52\n4 arima  constant    1.05    0.00435     241.  7.17e-181\n```\n\n\n:::\n:::\n\n\n\n\n-   Based on the acf of the residuals, is the MA model you identified a good fit to the data?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngdp_ma |>\n  residuals() |>\n  ACF(var = .resid) |>\n  autoplot()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `...` argument of `PACF()` is deprecated as of feasts 0.2.2.\nℹ ACF variables should be passed to the `y` argument. If multiple variables are\n  to be used, specify them using `vars(...)`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\nNone of the acf values are significant. The $MA(3)$ model seems appropriate.\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\nWe can write the estimated model as:\n$$\n  x_t = 1.0478741 + 0.9783408 \\mathbf{B} + 1.0127334 \\mathbf{B}^2 + 0.9651468 \\mathbf{B}^3\n$$\n\nThe absolute values of the roots of the right-hand side of this equation are:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ncoeffs <- tidy(gdp_ma) |>\n  # filter(term != \"constant\") |>\n  select(estimate) |>\n  pull()\n\nabs(polyroot(c(coeffs |> tail(1), coeffs |> head(-1))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.012232 1.059633 1.012232\n```\n\n\n:::\n:::\n\n\n\n\nThe model is invertible. (As mentioned [previously](#FittedModelWillBeInvertible), the process by which these are constructed guarantees they will be invertible.)\n\n\n\n\n\n\nsolution 4\n  \n    \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nvessels_ts <- rio::import(\"https://byuistats.github.io/timeseries/data/Vessels_Trade_US.csv\") |>\n  # filter(-comments) |>\n  mutate(\n    date = yearmonth(dmy(date)),\n    ratio = vessels / lag(vessels, 12)\n  ) |>\n  na.omit() |>\n  as_tsibble(index = date)\n\nvessels_ts |>\n  autoplot(.vars = ratio) +\n    labs(\n      x = \"Month\",\n      y = \"Ratio\",\n      title = \"Year-Over-Year Change in Net Tons on Vessels Cleared for Trade\"\n    ) +\n    theme_minimal() +\n    theme(plot.title = element_text(hjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nvessels_ts |>\n  select(ratio) |>\n  acf()\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-14-2.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nvessels_ts |>\n  select(ratio) |>\n  pacf()\n```\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-14-3.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngdp_ma <- vessels_ts |>\n  model(arima = ARIMA(ratio ~ 1 + pdq(0,0,12) + PDQ(0, 0, 0)))\n\ntidy(gdp_ma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 13 × 6\n   .model term     estimate std.error statistic   p.value\n   <chr>  <chr>       <dbl>     <dbl>     <dbl>     <dbl>\n 1 arima  ma1         0.572    0.0475     12.0  2.70e- 29\n 2 arima  ma2         0.558    0.0475     11.8  4.09e- 28\n 3 arima  ma3         0.601    0.0589     10.2  3.55e- 22\n 4 arima  ma4         0.488    0.0582      8.38 6.21e- 16\n 5 arima  ma5         0.430    0.0585      7.35 8.83e- 13\n 6 arima  ma6         0.457    0.0659      6.94 1.27e- 11\n 7 arima  ma7         0.323    0.0600      5.37 1.23e-  7\n 8 arima  ma8         0.358    0.0558      6.42 3.36e- 10\n 9 arima  ma9         0.479    0.0607      7.90 1.98e- 14\n10 arima  ma10        0.411    0.0514      7.99 1.04e- 14\n11 arima  ma11        0.517    0.0471     11.0  4.69e- 25\n12 arima  ma12       -0.306    0.0586     -5.22 2.70e-  7\n13 arima  constant    1.02     0.0171     59.8  2.45e-221\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngdp_ma |>\n  residuals() |>\n  ACF() |>\n  autoplot()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nResponse variable not specified, automatically selected `var = .resid`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](chapter_6_lesson_1_files/figure-html/unnamed-chunk-14-4.png){width=672}\n:::\n:::\n",
    "supporting": [
      "chapter_6_lesson_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}