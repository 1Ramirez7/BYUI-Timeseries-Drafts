---
title: "Chapter 2: Correlation"
format: html
editor: visual
---

```{r}
#| include: false
if (!require("pacman")) install.packages("pacman")
pacman::p_load("tsibble", "fable", 
    "feasts", "tsibbledata",
    "fable.prophet", "tidyverse",
    "patchwork",
    "ggthemes", "see",   # for okabeito color scheme
    "MASS", # for MVNorm
    "ggokabeito", "kableExtra", "stringr", "lubridate")

palette("okabeito")
okabeito_colors_list <- c(
    `orange` = "#E69F00",
    `light blue` = "#56B4E9",
    `green` = "#009E73",
    `yellow` = "#F0E442",
    `blue` = "#0072B2",
    `red` = "#D55E00",
    `purple` = "#CC79A7",
    `grey` = "#999999",
    `black` = "#000000",
    `sky blue` = "#56B4E9",
    `bluish green` = "#009E73",
    `vermillion` = "#D55E00",
    `reddish purple` = "#CC79A7",
    `dark yellow` = "#F5C710",
    `amber` = "#F5C710"
)


round_df <- function(df, digits) {
  nums <- vapply(df, is.numeric, FUN.VALUE = logical(1))
  df[,nums] <- round(df[,nums], digits = digits)
  (df)
}


round_to_places <- function(x, places) {
  # Initialize output  
  out <- rep_len("", length(x)) 
  
  # Handle NAs  
  out[is.na(x)] <- NA
  
  # Handle infinities
  inf <- is.infinite(x)
  out[inf & x > 0] <- "Inf"
  out[inf & x < 0] <- "-Inf"
  
  # Special cases
  finite <- !inf & !(is.na(x))
  
  # Round numbers
  x <- round(x, places)
  
  # Format numbers
  sgn <- sign(x)
  ints <- trunc(x)
  decs <- round(abs(x - ints) * 10^places)
  
  if (places > 0) {
    out[finite] <- paste0(ifelse(sgn[finite] >= 0, " ", "-"),
                          ints[finite], 
                          ".", 
                          decs[finite], 
                          strrep(0, places - nchar(as.integer(decs[finite])))
    )
  } else {
    out[finite] <- as.character(ints[finite])
  }
  
  return(out)
}

get_data_for_cov_table <- function(offset = 1) {
  # set random number generator seed
  set.seed(92401)
  
  # set parameters
  n <- 10
  rho <- 0.99
  mu <- 10
  sigma <- 3
  
  # build population correlation matrix
  tmp.r <- matrix(rho, n, n)
  tmp.r <- tmp.r^abs(row(tmp.r)-col(tmp.r))
  
  # simulate correlated normal random data
  x1 <- round(mvrnorm(1, rep(mu,n), sigma^2 * tmp.r),1)
  
  # build a data frame
  df <- data.frame(t = 1:length(x1),
                   x = x1,
                   y = lead(x1, offset)) %>%
    mutate(
      xx = x - mean(x),
      xx2 = xx^2,
      yy = y - mean(x),
      # yy2 = yy^2,
      xy = xx * yy
    ) %>% 
    dplyr::select(t, x, y, xx, xx2, yy, xy)
  
  return(df)
}

make_cov_table_df <- function(df, offset=1, decimals_1st_order = 4, decimals_2nd_order = 4) {
  # Color vector
  oi_colors <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#F5C710", "#CC79A7", "#999999")
  
  df_summary <- df %>% 
    summarize(
      x = sum(x),
      y = sum(y, na.rm = TRUE),
      xx = sum(xx),
      yy = sum(yy, na.rm = TRUE),
      xx2 = sum(xx2),
      # yy2 = sum(yy2, na.rm = TRUE),
      xy = sum(xy, na.rm = TRUE)
    ) %>% 
    round_df(3) %>% 
    mutate(
      t = paste0("sum"),
      x = round_to_places(x, 1),
      y = round_to_places(y, 1),
      xx = round_to_places(xx, decimals_1st_order),
      xx2 = round_to_places(xx2, decimals_2nd_order),
      yy = round_to_places(yy, decimals_1st_order),
      # yy2 = round_to_places(yy2, decimals_2nd_order),
      xy = round_to_places(xy, decimals_2nd_order)
    ) %>% 
    dplyr::select(t, x, y, xx, xx2, yy, xy)
  
  df %>%
    mutate(
      t = as.character(t),
      x = round_to_places(x, 1),
      y = round_to_places(y, 1),
      xx = round_to_places(xx, decimals_1st_order),
      xx2 = round_to_places(xx2, decimals_2nd_order),
      yy = round_to_places(yy, decimals_1st_order),
      # yy2 = round_to_places(yy2, decimals_2nd_order),
      xy = round_to_places(xy, decimals_2nd_order)
    ) %>% 
    mutate(
      x = cell_spec(x, 
                    color = case_when(
                      is.na(x) ~ "#999999",
                      TRUE ~ oi_colors[( row_number() + 0 ) %% 9 + 1]
                    )
      ),
      y = cell_spec(y, 
                    color = case_when(
                      is.na(y) ~ "#999999",
                      TRUE ~ oi_colors[( row_number() + offset ) %% 9 + 1]
                    )
      )
    ) %>% 
    mutate(
      # x = ifelse(row_number() > nrow(.) - offset, paste0("[",x,"]"), x),
      y = ifelse(row_number() > nrow(.) - offset, NA, y),
    ) %>% 
    replace(., is.na(.), "â€”") %>%
    bind_rows(df_summary) %>% 
    rename(
      "x_t" = x,
      "x_{t+k}" = y,
      # paste0("x_{t+", offset, "}") = y,
      "x_t-mean(x)" = xx, 
      "(x_t-mean(x))^2" = xx2, 
      "x_{t+k}-mean(x)" = yy,
      # "(x_{t+k}-mean(x))^2" = yy2, 
      "(x-mean(x))(x_{t+k}-mean(x))" = xy
    ) %>%
  return()
}

# Eliminates the values in columns 3 onward for a specified row_num
make_blank_row_in_cov_table <- function(df, row_num) {
  for (col_num in 3:ncol(df)) {
    df[row_num, col_num] = ""
  }
  return(df)
}

# Displays the kable table
display_table <- function(df) {
  df %>% 
    knitr::kable(format = "html", align='ccccccc', escape = FALSE, width = NA) %>%
    kable_styling(full_width = FALSE, "striped") 
}

# Compute summary values
compute_summaries <- function(df, digits = 4) {
  df %>% 
    summarize(
      mean_x = mean(x),
      mean_y = mean(y, na.rm = TRUE),
      ss_x = sum(xx2),
      # ss_y = sum(yy2, na.rm = TRUE),
      ss_xy = sum(xy, na.rm = TRUE),
      c_0 = sum(xx2) / nrow(.),
      c_k = sum(xy, na.rm = TRUE) / nrow(.),
      r_k = c_k / c_0
    ) %>% 
    round_df(digits)
}

```

# Lesson 2 (60 mins): Autocorrelation Concepts

## Objectives:

-   Define covariance, autocovariance, autocorrelation

-   Explain autocorrelation in time series

## Agenda:

## Introduction (5 mins)

-   Motivate studying autocorrelation

::: callout-caution
## TYSON: PLEASE BUILD A SHINY APP IN WHICH STUDENTS CAN PRESS A BUTTON TO REFRESH THE IMAGE BELOW AND OBSERVE DIFFERENT REALIZATIONS. PLEASE MAKE SLIDERS FOR THE PARAMETERS n (from 10 to 500 by 10), a (from 0 to 1 by 0.005), and n_reps (from 1 to 9 by 1).
:::

```{r}
#| echo: false
n <- 100      # Max 500
a <- .995     # Max 1
n_reps <- 5   # Max 9
sigma <- 1    # This just changes the vertical axis scale; it can be a constant 1

df <- data.frame()
for(i in 1:n_reps){
  x1 <- rep(0, n)
  for(j in 2:n){
    x1[j] = a * x1[j-1] + rnorm(1, mean = 0, sd = sigma)
  } 
  
  temp <- data.frame(i = 1:length(x1),
                    x = x1,
                    rep = i)
  
  df <- rbind(df, temp)
}

ggplot(df, aes(x = i, y = x, color = factor(rep))) +
  # geom_line() +
  geom_line(linewidth = ifelse(df$rep == 1, 1, 0.5)) +
  scale_color_okabeito(
  palette = "full",
  reverse = TRUE,
  order = c(1,7,8,5,6,3,4,2,9),
  aesthetics = "color"
) +
  labs(title = paste0(n_reps," Realizations of a Stationary Time Series"),
       x = "Time",
       y = "x") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  guides(color = guide_legend(title = "Realization"))
```

-   Use the figure above to explain the following vocabulary terms:

    -   Ensemble of a time series

    -   Realization of a time series

-   If a time series displays an upward trend, can we conclude that trend will continue in the same direction? Why or why not?

## Hands-on Exercise -- Exploring Sample Autocorrelation (40 min)

<!-- Compute sample acvf and acf -->

In the previous lesson, we computed the sample covariance and sample correlation coefficient between two independent variables. When working with time series, the observations are not independent. There is often a relationship between sequential observations. We will compute the autocovariance function and autocorrelation function for a time series.

Note: the prefix "auto" comes from a Greek root meaning "self." We will be finding the autocovariance and correlation of a time series with itself. First, we start with a lag of 1. With a lag of 1 the corresponding values of the time series that are being compared are shifted by one time unit. Then, we will consider any integer lag: lag $k$.

### Lag $k$ Sample Autocovariance Function (acvf), $c_k$

The **lag** $k$ sample autocovariance function, acvf, denoted $c_k$, is defined as

$$
  c_k = \frac{1}{n} \sum\limits_{t=1}^{n-k}(x_t-\bar x)(x_{t+k}-\bar x)
$$

We denote the lag by the letter $k$. This is the number of values the data set is shifted to compute the autocovariance.

-   What is the equation for $c_0$, the value of the autocovariance function with lag $k=0$?

### Lag $k=1$ Sample Autocovariance Function, $c_1$

We will now find the autocovariance between the values in a time series ($x = x_t$) and the same values, shifted by one unit of time ($y = x_{t+1}$).

```{r}
#| echo: false
offset_value <- 1
cov_df <- get_data_for_cov_table(offset = offset_value)
cov_table <- cov_df %>%
  make_cov_table_df(offset = offset_value, decimals_1st_order = 1, decimals_2nd_order = 2) 
cov_table %>%
  display_table()

summarized <- compute_summaries(cov_df)

ggplot(cov_df %>% na.omit(), aes(x = x, y = y)) +
  geom_point(size = 2, colour= "#56B4E9") +
  xlab(expression(x[t])) +
  ylab(expression(x[t+1])) +
  theme_bw() +  
  ggtitle(paste0("Data pairs with a lag of k=",offset_value)) + 
  theme(plot.title = element_text(hjust = 0.5)) 
```

```{r}
#| echo: false
# Obtain the number of data values.
n <- nrow(cov_df)
```

Here are the values observed in a time series. We will use these to explore 

```{r}
#| echo: false

cov_df %>%
  dplyr::select(t, x, y) %>% 
  rename(x_t = x, `x_t+1` = y) %>% 
  display_table()
```

You can use the following command to read the observations into R.

```{r}
#| echo: false

cat("x <- c(",paste(cov_df$x, collapse = ", "),")")
```

Note that

$$
  \bar x 
    = \frac{1}{n} \sum\limits_{t=1}^{n} x_t 
    = \frac{1}{`r n`} \cdot `r sum(cov_df$x) %>% round(4)`
    = `r summarized$mean_x`
$$

In this example, the second variable is $x_{t+1}$, where $t>1$. the autocovariance of $x_t$ and $x_{t+1}$ is:

$$
  c_1 
    = \frac{1}{n} \sum\limits_{t=1}^{n-1}(x_t-\bar x)(x_{t+1}-\bar x)
    = \frac{1}{`r n`} \sum\limits_{t=1}^{`r n - offset_value`}(x_t-\bar x)(x_{t+1}-\bar x)
  = \frac{1}{`r n`} \cdot `r summarized$ss_xy`
  = `r summarized$c_k`
$$

This is the (auto)covariance of $x$ with itself, but with a lag of 1 time unit. This is the value of the **lag** $k=1$ autocovariance function, acvf_1.

-   What does the lag 1 autocovariance measure?

### Lag $k$ Sample Autocorrelation Function (acf), $r_k$

The **sample autocorrelation function, acf**, denoted $r_k$, where $k$ is the lag, is defined as

$$
  r_k 
    = \frac{c_k}{c_0} 
    = \frac{ \frac{1}{n} \sum\limits_{t=1}^{n-k}(x_t-\bar x)(x_{t+k}-\bar x) }{ \frac{1}{n} \sum\limits_{t=1}^{n}(x_t-\bar x)^2 }
    = \frac{ \sum\limits_{t=1}^{n-k}(x_t-\bar x)(x_{t+k}-\bar x) }{ \sum\limits_{t=1}^{n}(x_t-\bar x)^2 }
$$

Note that $c_0$ is the variance of $x$, computed by dividing by $n$, instead of $n-1$.

### Lag $k=1$ Sample Autocorrelation Function, $r_1$

We can compute the **lag 1 autocorrelation** or the **autocorrelation of** $x$ with lag 1 as the quotient $r_1 = \frac{c_1}{c_0}$, where $$ c_1 = \sum\limits_{t=1}^{n-k} (x_t-\bar x)(x_{t+k}-\bar x) $$ by $$ c_0 = \sum\limits_{t=1}^{n} (x_t-\bar x)^2 $$


First, we compute $c_0$: $$ 
  c_0 
    = \frac{1}{`r n`} \sum\limits_{t=1}^{n} (x_t-\bar x)^2 
    = \frac{1}{`r n`} \cdot `r summarized$ss_x %>% round(4)`
    = `r summarized$c_0 %>% round(4)`
$$

Now, we use $c_0$ to compute $r_1$:

```{=tex}
\begin{align*}
  r_1
  &= \frac{c_1}{c_0} 
  =
  \frac{ \frac{1}{n} \sum\limits_{t=1}^{`r n - offset_value`}(x_t-\bar x)(x_{t+1}-\bar x)
      }{
          \frac{1}{n} \sum\limits_{t=1}^{`r n`}(x_t-\bar x)^2
      }  
  =
  \frac{`r summarized$c_k`}{`r summarized$c_0`}
  = `r summarized$r_k %>% round(4)`
  \\
  &= 
  \frac{ \sum\limits_{t=1}^{`r n - offset_value`}(x_t-\bar x)(x_{t+1}-\bar x)
      }{
          \sum\limits_{t=1}^{`r n`}(x_t-\bar x)^2
      } 
  =
  \frac{
        `r summarized$ss_xy`
  }{
    `r summarized$ss_x`
  }
  = `r summarized$r_k %>% round(4)`
\end{align*}
```
-   What does the lag 1 autocorrelation measure?


```{r}
#| echo: false

# Initialize table
auto_cov_cor_table <- data.frame(lag = integer(),
                  autocovariance = double(),
                  autocorrelation = double())
```

```{r}
#| echo: false

# Add rows to the table
auto_cov_cor_table <- auto_cov_cor_table %>% 
  bind_rows(c(
    lag = offset_value, 
    autocovariance = summarized$c_k, 
    autocorrelation = summarized$r_k
    )
  )

# # Display the table, except row 2
# auto_cov_cor_table %>%
#   mutate( ####################################### Suppresses row 2
#     autocovariance = ifelse(row_number() == 2,"", autocovariance),
#     autocorrelation = ifelse(row_number() == 2,"", autocorrelation)
#   ) %>% 
#   knitr::kable(format = "html", align='ccc', escape = FALSE, width = NA) %>%
#   kable_styling(full_width = FALSE, "striped") 
```

### $k = 2$

```{r}
#| echo: false
offset_value <- 2
cov_df <- get_data_for_cov_table(offset = offset_value)
cov_table <- cov_df %>%
  make_cov_table_df(offset = offset_value, decimals_1st_order = 1, decimals_2nd_order = 2) 
cov_table %>%
  ############ Let students fill in these rows ##########
  make_blank_row_in_cov_table(3) %>% 
  make_blank_row_in_cov_table(4) %>% 
  make_blank_row_in_cov_table(5) %>% 
  # make_blank_row_in_cov_table(6) %>% 
  make_blank_row_in_cov_table(11) %>% 
  display_table()

summarized <- compute_summaries(cov_df)

ggplot(cov_df %>% na.omit(), aes(x = x, y = y)) +
  geom_point(size = 2, colour= "#56B4E9") +
  xlab(expression(x[t])) +
  ylab(expression(x[t+2])) +
  theme_bw() +  
  ggtitle(paste0("Data pairs with a lag of k=",offset_value)) + 
  theme(plot.title = element_text(hjust = 0.5)) 
```

```{r}
#| echo: false

# Add rows to the table
auto_cov_cor_table <- auto_cov_cor_table %>% 
  bind_rows(c(
    lag = offset_value, 
    autocovariance = summarized$c_k, 
    autocorrelation = summarized$r_k
    )
  )

# # Display the table, except row 2
# auto_cov_cor_table %>%
#   # mutate( ####################################### Suppresses row 2
#   #   autocovariance = ifelse(row_number() == 2,"", autocovariance),
#   #   autocorrelation = ifelse(row_number() == 2,"", autocorrelation)
#   # ) %>% 
#   knitr::kable(format = "html", align='ccc', escape = FALSE, width = NA) %>%
#   kable_styling(full_width = FALSE, "striped") 
```

### $k = 3$

```{r}
#| echo: false
offset_value <- 3
cov_df <- get_data_for_cov_table(offset = offset_value)
cov_table <- cov_df %>%
  make_cov_table_df(offset = offset_value, decimals_1st_order = 1, decimals_2nd_order = 2) 
cov_table %>%
  display_table()

summarized <- compute_summaries(cov_df)

ggplot(cov_df %>% na.omit(), aes(x = x, y = y)) +
  geom_point(size = 2, colour= "#56B4E9") +
  xlab(expression(x[t])) +
  ylab(expression(x[t+3])) +
  theme_bw() +  
  ggtitle(paste0("Data pairs with a lag of k=",offset_value)) + 
  theme(plot.title = element_text(hjust = 0.5)) 
```

```{r}
#| echo: false

# Add rows to the table
auto_cov_cor_table <- auto_cov_cor_table %>% 
  bind_rows(c(
    lag = offset_value, 
    autocovariance = summarized$c_k, 
    autocorrelation = summarized$r_k
    )
  )

# # Display the table, except row 2
# auto_cov_cor_table %>%
#   mutate( ####################################### Suppresses row 2
#     autocovariance = ifelse(row_number() == 2,"", autocovariance),
#     autocorrelation = ifelse(row_number() == 2,"", autocorrelation)
#   ) %>% 
#   knitr::kable(format = "html", align='ccc', escape = FALSE, width = NA) %>%
#   kable_styling(full_width = FALSE, "striped") 
```

### $k = 4$

```{r}
#| echo: false
offset_value <- 4
cov_df <- get_data_for_cov_table(offset = offset_value)
cov_table <- cov_df %>%
  make_cov_table_df(offset = offset_value, decimals_1st_order = 1, decimals_2nd_order = 2) 
cov_table %>%
  display_table()

summarized <- compute_summaries(cov_df)

ggplot(cov_df %>% na.omit(), aes(x = x, y = y)) +
  geom_point(size = 2, colour= "#56B4E9") +
  xlab(expression(x[t])) +
  ylab(expression(x[t+4])) +
  theme_bw() +  
  ggtitle(paste0("Data pairs with a lag of k=",offset_value)) + 
  theme(plot.title = element_text(hjust = 0.5)) 
```

```{r}
#| echo: false

# Add rows to the table
auto_cov_cor_table <- auto_cov_cor_table %>% 
  bind_rows(c(
    lag = offset_value, 
    autocovariance = summarized$c_k, 
    autocorrelation = summarized$r_k
    )
  )

# Display the table, including row 2
auto_cov_cor_table %>%
  # mutate( ####################################### Suppresses row 2
  #   autocovariance = ifelse(row_number() == 2,"", autocovariance),
  #   autocorrelation = ifelse(row_number() == 2,"", autocorrelation)
  # ) %>% 
  knitr::kable(format = "html", align='ccc', escape = FALSE, width = NA) %>%
  kable_styling(full_width = FALSE, "striped") 
```


### Correlograms

-   The table below gives the sample autocorrelation function, acf, for this data set. Use these values to sketch a correlogram. The figure below can help you begin.

```{r}
#| echo: false

acf(cov_df$x, plot=FALSE, type = "correlation") 
# acf(cov_df$x, plot=TRUE, type = "correlation") 

ggplot(data = cov_df, aes(x = seq_along(x), y = acf(x, plot = FALSE)$acf)) +
  # geom_col() +
  ylim(-1, 1) +
  scale_x_continuous(breaks = 0:9) + 
  geom_segment(aes(x = 0, y = 0, xend = 0, yend = 1)) + 
  geom_segment(aes(x = 0, y = 0, xend = 9, yend = 0)) + ## Hack
  geom_hline(yintercept = 0, linetype = "solid", linewidth=1, color = "black") +
  geom_hline(yintercept = -0.62, linetype = "dashed", linewidth=1, color = "#56B4E9") +
  geom_hline(yintercept = 0.62, linetype = "dashed", linewidth=1, color = "#56B4E9") +  # Should be (-0.1 +/- 2/sqrt(10))
  labs(x = "Lag", y = "ACF") +
  # theme_bw()   
  # theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank())
  theme_bw() +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank()
  )
```

<!-- -   Finish a partially-created correlogram with the r_k values computed -->

-   Show a correlogram with seasonal data with a period of one year (chocolate data?). What do the spikes tell us?


## Recap (5 mins)

-   Review objectives and key points

<!-- -->

-   Formally define autocovariance, autocorrelation

-   Explain autocorrelation in time series context

::: callout-caution
## TYSON: PLEASE BUILD A SHINY APP IN WHICH STUDENTS CAN CHANGE THE AUTOCORRELATION COEFFICIENT (SLIDER FOR AUTOCORRELATION FROM 0 TO 1) AND WATCH THE GRAPH UPDATE IN REAL TIME
:::

```{r}
library(tidyverse)
library(zoo) 

# Generate data
set.seed(101) 
x <- 1:100*0.5 + arima.sim(n=100-1, list(ar=0.1, ma=0.2, order=c(1,1,1)))
e <- rnorm(100, 0, 2.5)
y <- 1:100*0.5 + e  
z <- zoo(y, order.by = 1:100)

# Create data frame  
df <- data.frame(
  time = 1:100,
  x = x,
  z = coredata(z)
)

# Plot  
ggplot(df, aes(x = time)) +
  geom_line(aes(y = x, color = "X")) + 
  geom_line(aes(y = z, color = "Z")) +
  labs(title="X vs Z Series", 
       x="Time",
       y="Values",
       color="Series") +
  theme_bw()
```

## Example Analysis (15 mins)

Walk through sample autocorrelation analysis

## Recap (20 mins)

-   Review objectives and key concepts

-   Clarify questions on autocorrelation

## Assessment:

-   Write definitions of autocovariance and autocorrelation

# Lesson 2 (60 mins): Correlograms

## Objectives:

-   Compute sample autocorrelations

-   Make and interpret correlogram plots

## Agenda:

## Introduction (5 mins)

-   Introduce correlogram plots

## Lecture (15 mins)

-   Demonstrate computing acf/pacf in R

-   Explain interpreting correlogram plots

## Hands-on Exercise (25 mins)

-   Compute acf/pacf on sample data

-   Make correlogram plots in R

-   Identify significant lags/correlations

## Assessment:

-   Compute and interpret acf/pacf on data

```{r}
#| include: false
#| eval: false

##################### THIS IS FOR CHOOSING THE SEED ##################

reps <- 5000
prodxy <- meanx <- meany <- sdx <- sdy <- covs <- cors <- rep(0,reps)
for (i in 1:reps){
  # Unset random seed
  set.seed(i)
  
# Specify means and correlation coefficient
n <- 6              # number of points
mu <- c(3, 1)       # mean vector (mu_x, mu_y)
sigma_x <- 3.5      # standard deviation x
sigma_y <- 2        # standard deviation y
rho <- -0.85          # correlation coefficient
  
  # Define variance-covariance matrix
  sigma <- matrix(
    c(sigma_x^2,
      rho*sigma_x*sigma_y,
      rho*sigma_x*sigma_y,
      sigma_y^2),
    nrow = 2)
  
  # Simulate bivariate normal data
  mvn_data_6 <- MASS::mvrnorm(n, mu, sigma) %>% 
    data.frame() %>% 
    rename(x = X1, y = X2) %>% 
    round_df(1)
  meanx[i] <- mean(mvn_data_6$x)
  meany[i] <- mean(mvn_data_6$y)
  prodxy[i] <- prod((mvn_data_6$x - meanx[i]) * (mvn_data_6$y - meany[i]))
  sdx[i] <- sd(mvn_data_6$x)
  sdy[i] <- sd(mvn_data_6$y)
  cors[i] <- cor(mvn_data_6$x, mvn_data_6$y)
  covs[i] <- cov(mvn_data_6$x, mvn_data_6$y) 
}
temp0 <- data.frame(meanx = meanx, meany = meany, sdx = sdx, sdy = sdy, cors = cors, covs = covs, prodxy = prodxy) %>% 
  mutate(i = row_number()) %>% 
  filter(meanx*10 == floor(meanx*10)) %>% 
  filter(meany*10 == floor(meany*10))  %>% 
  filter(covs*100 == floor(covs*100))  %>% 
  mutate(across(everything(), as.character)) 

View(temp0)
```

::: callout-note
Some important information....
:::

::: callout-warning
Some important information....
:::

::: callout-important
Some important information....
:::

::: callout-tip
Some important information....
:::

::: callout-caution
Some important information....
:::
