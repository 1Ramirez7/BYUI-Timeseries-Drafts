---
title: "Chapter 2: Correlation"
format: html
editor: visual
---

```{r}
#| include: false
if (!require("pacman")) install.packages("pacman")
pacman::p_load("tsibble", "fable", 
    "feasts", "tsibbledata",
    "fable.prophet", "tidyverse",
    "patchwork",
    "ggthemes", "see",   # for okabeito color scheme
    "MASS" # for MVNorm
    )
pacman::p_load(ggokabeito, kableExtra, stringr, lubridate)

palette("okabeito")
okabeito_colors_list <- c(
    `orange` = "#E69F00",
    `light blue` = "#56B4E9",
    `green` = "#009E73",
    `yellow` = "#F0E442",
    `blue` = "#0072B2",
    `red` = "#D55E00",
    `purple` = "#CC79A7",
    `grey` = "#999999",
    `black` = "#000000",
    `sky blue` = "#56B4E9",
    `bluish green` = "#009E73",
    `vermillion` = "#D55E00",
    `reddish purple` = "#CC79A7",
    `dark yellow` = "#F5C710",
    `amber` = "#F5C710"
)


round_df <- function(df, digits) {
  nums <- vapply(df, is.numeric, FUN.VALUE = logical(1))
  df[,nums] <- round(df[,nums], digits = digits)
  (df)
}


round_to_places <- function(x, places) {
  # Initialize output  
  out <- rep_len("", length(x)) 
  
  # Handle NAs  
  out[is.na(x)] <- NA
  
  # Handle infinities
  inf <- is.infinite(x)
  out[inf & x > 0] <- "Inf"
  out[inf & x < 0] <- "-Inf"
  
  # Special cases
  finite <- !inf & !(is.na(x))
  
  # Round numbers
  x <- round(x, places)
  
  # Format numbers
  ints <- trunc(x)
  decs <- round(abs(x - ints) * 10^places)
  
  if (places > 0) {
    out[finite] <- paste0(ints[finite], ".", decs[finite], strrep(0, places - nchar(as.integer(decs[finite]))))
  } else {
    out[finite] <- as.character(ints[finite])
  }
  
  return(out)
}

get_data_for_cov_table <- function(offset = 1) {
  # set random number generator seed
  # set.seed(532)
  # set.seed(11626)
  # set.seed(24456)
  # set.seed(9203)
  ## n = 11 below
  # set.seed(15769)
  set.seed(92401)
  
  # set parameters
  n <- 10
  rho <- 0.99
  mu <- 10
  sigma <- 3
  
  # build population correlation matrix
  tmp.r <- matrix(rho, n, n)
  tmp.r <- tmp.r^abs(row(tmp.r)-col(tmp.r))
  
  # simulate correlated normal random data
  x1 <- round(mvrnorm(1, rep(mu,n), sigma^2 * tmp.r),1)
  
  # build a data frame
  df <- data.frame(t = 1:length(x1),
                   x = x1,
                   y = lead(x1, offset)) %>%
    mutate(
      xx = x - mean(x),
      xx2 = xx^2,
      yy = y - mean(x),
      yy2 = yy^2,
      xy = xx * yy
    ) %>% 
    dplyr::select(t, x, y, xx, xx2, yy, yy2, xy)
  
  return(df)
}

make_cov_table_df <- function(df, offset=1, decimals_1st_order = 4, decimals_2nd_order = 4) {
  # Color vector
  oi_colors <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#F5C710", "#CC79A7", "#999999")
  
  df_summary <- df %>% 
    summarize(
      x = sum(x),
      y = sum(y, na.rm = TRUE),
      xx = sum(xx),
      yy = sum(yy, na.rm = TRUE),
      xx2 = sum(xx2),
      yy2 = sum(yy2, na.rm = TRUE),
      xy = sum(xy, na.rm = TRUE)
    ) %>% 
    round_df(3) %>% 
    mutate(
      t = paste0("sum"),
      x = round_to_places(x, 1),
      y = round_to_places(y, 1),
      xx = round_to_places(xx, decimals_1st_order),
      xx2 = round_to_places(xx2, decimals_2nd_order),
      yy = round_to_places(yy, decimals_1st_order),
      yy2 = round_to_places(yy2, decimals_2nd_order),
      xy = round_to_places(xy, decimals_2nd_order)
    ) %>% 
    dplyr::select(t, x, y, xx, xx2, yy, yy2, xy)
  
  df %>%
    mutate(
      t = as.character(t),
      x = round_to_places(x, 1),
      y = round_to_places(y, 1),
      xx = round_to_places(xx, decimals_1st_order),
      xx2 = round_to_places(xx2, decimals_2nd_order),
      yy = round_to_places(yy, decimals_1st_order),
      yy2 = round_to_places(yy2, decimals_2nd_order),
      xy = round_to_places(xy, decimals_2nd_order)
    ) %>% 
    mutate(
      x = cell_spec(x, 
                    color = case_when(
                      is.na(x) ~ "#999999",
                      TRUE ~ oi_colors[( row_number() + 0 ) %% 9 + 1]
                    )
      ),
      y = cell_spec(y, 
                    color = case_when(
                      is.na(y) ~ "#999999",
                      TRUE ~ oi_colors[( row_number() + offset ) %% 9 + 1]
                    )
      )
    ) %>% 
    mutate(
      # x = ifelse(row_number() > nrow(.) - offset, paste0("[",x,"]"), x),
      y = ifelse(row_number() > nrow(.) - offset, NA, y),
    ) %>% 
    replace(., is.na(.), "â€”") %>%
    bind_rows(df_summary) %>% 
    rename(
      "x_t" = x,
      "x_{t+k}" = y,
      "x_t-mean(x)" = xx, 
      "(x_t-mean(x))^2" = xx2, 
      "x_{t+k}-mean(x)" = yy,
      "(x_{t+k}-mean(x))^2" = yy2, 
      "(x-mean(x))(x_{t+k}-mean(x))" = xy
    ) %>%
  return()
}

# Eliminates the values in columns 3 onward for a specified row_num
make_blank_row_in_cov_table <- function(df, row_num) {
  for (col_num in 3:ncol(df)) {
    df[row_num, col_num] = ""
  }
  return(df)
}

# Displays the kable table
display_cov_table <- function(df) {
  df %>% 
    knitr::kable(format = "html", align='cccccccc', escape = FALSE, width = NA) %>%
    kable_styling(full_width = FALSE, "striped") 
}

# Compute summary values
compute_summaries <- function(df, digits = 10) {
  df %>% 
    summarize(
      mean_x = round(mean(x), digits),
      mean_y = round(mean(y, na.rm = TRUE), digits),
      ss_x = round(sum(xx2), digits),
      ss_y = round(sum(yy2, na.rm = TRUE), digits),
      ss_xy = round(sum(xy, na.rm = TRUE), digits),
      cov_xy = round(mean(xy, na.rm = TRUE), digits)
    ) %>% 
    mutate(cor_xy = ss_xy / ss_x) 
}

# Compute the (auto)covariance
compute_cov <- function(df, digits = 4) {
  df %>% 
    na.omit() %>% 
    summarize(
      cov_xy = round(cov(x,y), digits)
    ) %>% 
    pull() %>% 
    return()
}

# Compute the variance of x
compute_varx <- function(df, digits = 4) {
  df %>% 
    na.omit() %>% 
    summarize(
      var_x = round(var(x), digits)
    ) %>% 
    pull() %>% 
    return()
}

# Compute the variance of y
compute_vary <- function(df, digits = 4) {
  df %>% 
    na.omit() %>% 
    summarize(
      var_y = round(var(y), digits)
    ) %>% 
    pull() %>% 
    return()
}

# Compute the (auto)correlation coefficient
compute_cor <- function(df, digits = 4) {
  df %>% 
    na.omit() %>% 
    summarize(
      cov_xy = round(cor(x,y), digits)
    ) %>% 
    pull() %>% 
    return()
}

```

# Lesson 2 (60 mins): Autocorrelation Concepts

## Objectives:

-   Define covariance, autocovariance, autocorrelation

-   Explain autocorrelation in time series

## Agenda:

## Introduction (5 mins)

-   Motivate studying autocorrelation

::: callout-caution
## TYSON: PLEASE BUILD A SHINY APP IN WHICH STUDENTS CAN PRESS A BUTTON TO REFRESH THE IMAGE BELOW AND OBSERVE DIFFERENT REALIZATIONS. PLEASE MAKE SLIDERS FOR THE PARAMETERS n (from 10 to 500 by 10), a (from 0 to 1 by 0.005), and n_reps (from 1 to 9 by 1).
:::

```{r}
#| echo: false
n <- 100      # Max 500
a <- .995     # Max 1
n_reps <- 5   # Max 9
sigma <- 1    # This just changes the vertical axis scale; it can be a constant 1

df <- data.frame()
for(i in 1:n_reps){
  x1 <- rep(0, n)
  for(j in 2:n){
    x1[j] = a * x1[j-1] + rnorm(1, mean = 0, sd = sigma)
  } 
  
  temp <- data.frame(i = 1:length(x1),
                    x = x1,
                    rep = i)
  
  df <- rbind(df, temp)
}

ggplot(df, aes(x = i, y = x, color = factor(rep))) +
  geom_line() +
  scale_color_okabeito(
  palette = "full",
  reverse = TRUE,
  order = c(1,7,8,5,6,3,4,2,9),
  aesthetics = "color"
) +
  labs(title = paste0(n_reps," Realizations of a Stationary Time Series"),
       x = "Time",
       y = "x") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  guides(color = guide_legend(title = "Realization"))

# acf(df %>% filter(rep == 1) %>% dplyr::select(x), plot=FALSE, lag.max=5)
```

-   Use the figure above to explain the following vocabulary terms:

    -   Ensemble of a time series

    -   Realization of a time series

-   If a time series displays an upward trend, can we conclude that trend will continue in the same direction? Why or why not?

## Hands-on Exercise -- Exploring Sample Autocorrelation (40 min)

<!-- Compute sample acvf and acf -->

In the previous lesson, we computed the sample covariance and sample correlation coefficient between two independent variables. When working with time series, the observations are not independent. There is often a relationship between sequential observations. We will compute the autocovariance function and autocorrelation function for a time series.

Note: the prefix "auto" comes from a Greek root meaning "self." We will be finding the autocovariance and correlation of a time series with itself. First, we start with a lag of 1. With a lag of 1 the corresponding values of the time series that are being compared are shifted by one time unit. Then, we will consider any integer lag: lag $k$.

### (Lag 1) Sample Autocovariance

We will now find the autocovariance between the values in a time series ($x = x_t$) and the same values, with a lag of one time period ($y = x_{i+1}$). We denote the lag by the letter $k$, so we have a lag of $k=1$.

<!-- Here is a time series: -->

<!-- ```{r} -->

<!-- #| echo: false  -->

<!-- n <- 20 -->

<!-- a <- .995 -->

<!-- sigma <- 1 -->

<!-- n_reps <- 1 -->

<!-- x1 <- rep(0, n) -->

<!-- x1[1] <- rnorm(1, mean = 10, sd = 1) -->

<!-- for(j in 2:n){ -->

<!--   x1[j] = a * x1[j-1] + rnorm(1, mean = 0, sd = sigma) -->

<!-- }  -->

<!-- df <- data.frame(i = 1:length(x1), -->

<!--                  x = x1) -->

<!-- df -->

<!-- # acf(df %>% filter(rep == 1) %>% dplyr::select(x), plot=FALSE, lag.max=5) -->

<!-- ``` -->



```{r}
offset_value <- 1
cov_df <- get_data_for_cov_table(offset = offset_value)
cov_table <- cov_df %>%
  make_cov_table_df(offset = offset_value, decimals_1st_order = 1, decimals_2nd_order = 2) 
cov_table %>%
  display_cov_table()

ggplot(cov_df %>% na.omit(), aes(x = x, y = y)) +
  geom_point(size = 2, colour= "#56B4E9") +
  # scale_color_manual(values = c("#E69F00", "#56B4E9"),  
  #                    labels = c(expression((x-bar(x))(y-bar(y))<0),
  #                               expression((x-bar(x))(y-bar(y))>0))) +
  # geom_vline(xintercept = mean(cov_dat$x), color = "#009E73") + 
  # geom_hline(yintercept = mean(cov_dat$y), color = "#009E73") +
  xlab(expression(x[t])) +
  ylab(expression(x[t+1])) +
  theme_bw() +  
  ggtitle("Simulated data pairs with a lag of k=1") + 
  theme(plot.title = element_text(hjust = 0.5)) 
```

```{r}
# Obtain the number of data values.
n <- nrow(cov_df)
```




In this case, the second variable is $x_{t+1}$, where $t>1$. the autocovariance of $x_t$ and $x_{t+1}$ is:

FIX THIS 

FIX THIS 

FIX THIS 

FIX THIS 

FIX THIS 
$$
  cov(x,y) = \frac{\sum\limits_{t=1}^{`r n - offset_value`}(x_t-\bar x)(x_{t+k}-\bar x)}{n} 
= \frac{`r as.numeric(cov_table[nrow(cov_table),8])`}{`r n - offset_value`}
= `r compute_summaries(cov_df, digits = 4)$cov_xy`
$$

This is the autocovariance of $x$ with itself, but with a lag of 1 time unit. This is called the **lag 1 autocovariance** or the **autocovariance of** $x$ with lag 1.

-   What does the lag 1 autocovariance measure?

### (Lag 1) Autocorrelation Coefficient

We can compute the **lag 1 autocorrelation** or the **autocorrelation of** $x$ with lag 1 by dividing the autocovariance by the square roots of the variances of $x_t$ and $x_{t+1}$:

$$
\begin{align*}
  cor(x,y) 
  &= \frac{cov(x,y)}{\sqrt{s_x} \cdot \sqrt{s_y}} 
  =
  \frac{ \frac{\sum\limits_{t=1}^{`r n - offset_value`}(x_t-\bar x)(x_{t+k}-\bar x)}{n}
      }{
        \sqrt{
          \frac{\sum\limits_{t=1}^{`r n`}(x_t-\bar x)^2}{n}
        }
        \sqrt{
          \frac{\sum\limits_{t=1}^{`r n - offset_value`}(x_{t+k}-\bar x)^2}{n}
        }
      }  
  \\
  &= 
  \frac{ \sum\limits_{t=1}^{`r n - offset_value`}(x_t-\bar x)(x_{t+k}-\bar x)
      }{
        \sqrt{
          \sum\limits_{t=1}^{`r n`}(x_t-\bar x)^2
        }
        \sqrt{
          \sum\limits_{t=1}^{`r n - offset_value`}(x_{t+k}-\bar x)^2
        }
      } 
  =
  \frac{
        `r as.numeric(cov_table[nrow(cov_table),8])`
  }{
    \sqrt{ `r as.numeric(cov_table[nrow(cov_table),5])` }
    \sqrt{ `r as.numeric(cov_table[nrow(cov_table),7])` }
  }
  = `r compute_cor(cov_df)`
\end{align*}
$$


$$
\begin{align*}
  DUH_cor(x,y) 
  &= \frac{c_k}{c_0} 
  =
  \frac{ \frac{1}{n} \sum\limits_{t=1}^{`r n - offset_value`}(x_t-\bar x)(x_{t+k}-\bar x)
      }{
          \frac{1}{n} \sum\limits_{t=1}^{`r n`}(x_t-\bar x)^2
      }  
  \\
  &= 
  \frac{ \sum\limits_{t=1}^{`r n - offset_value`}(x_t-\bar x)(x_{t+k}-\bar x)
      }{
          \sum\limits_{t=1}^{`r n`}(x_t-\bar x)^2
      } 
  =
  \frac{
        `r as.numeric(cov_table[nrow(cov_table),8])`
  }{
    \sqrt{ `r as.numeric(cov_table[nrow(cov_table),5])` }
    \sqrt{ `r as.numeric(cov_table[nrow(cov_table),7])` }
  }
  = `r compute_cor(cov_df)`
\end{align*}
$$

-   What does the lag 1 autocorrelation measure?

We will summarize these values in a table:

```{r}
#| echo: false

# Initialize table
auto_cov_cor_table <- data.frame(lag = integer(),
                  autocovariance = double(),
                  autocorrelation = double())
```

```{r}
#| echo: false

# Add rows to the table
auto_cov_cor_table <- auto_cov_cor_table %>% bind_rows(c(lag = offset_value, autocovariance = compute_cov(cov_df), autocorrelation = compute_cor(cov_df)))

# Display the table, except row 2
auto_cov_cor_table %>%
  mutate( ####################################### Suppresses row 2
    autocovariance = ifelse(row_number() == 2,"", autocovariance),
    autocorrelation = ifelse(row_number() == 2,"", autocorrelation)
  ) %>% 
  knitr::kable(format = "html", align='ccc', escape = FALSE, width = NA) %>%
  kable_styling(full_width = FALSE, "striped") 
```

```{r}
offset_value <- 2
cov_df <- get_data_for_cov_table(offset = offset_value)
cov_table <- cov_df %>%
  make_cov_table_df(offset = offset_value, decimals_1st_order = 1, decimals_2nd_order = 2) 
cov_table %>%
  # make_blank_row_in_cov_table(3) %>%
  # make_blank_row_in_cov_table(4) %>%
  # make_blank_row_in_cov_table(5) %>%
  # make_blank_row_in_cov_table(6) %>%
  display_cov_table()
```

```{r}
#| echo: false

# Add rows to the table
auto_cov_cor_table <- auto_cov_cor_table %>% bind_rows(c(lag = offset_value, autocovariance = compute_cov(cov_df), autocorrelation = compute_cor(cov_df)))

# Display the table, except row 2
auto_cov_cor_table %>%
  mutate(
    autocovariance = ifelse(row_number() == 2,"", autocovariance),
    autocorrelation = ifelse(row_number() == 2,"", autocorrelation)
  ) %>% 
  knitr::kable(format = "html", align='ccc', escape = FALSE, width = NA) %>%
  kable_styling(full_width = FALSE, "striped") 
```

```{r}
# cov_df3 <- get_data_for_cov_table(offset = 3)
# cov_df3 %>%
#   make_cov_table_df(offset = 3) %>% 
#   display_cov_table()

offset_value <- 3
cov_df <- get_data_for_cov_table(offset = offset_value)
cov_table <- cov_df %>%
  make_cov_table_df(offset = offset_value, decimals_1st_order = 1, decimals_2nd_order = 2) 
cov_table %>%
  display_cov_table()
```

```{r}
#| echo: false

# Add rows to the table
auto_cov_cor_table <- auto_cov_cor_table %>% bind_rows(c(lag = offset_value, autocovariance = compute_cov(cov_df), autocorrelation = compute_cor(cov_df)))

# Display the table, except row 2
auto_cov_cor_table %>%
  mutate(
    autocovariance = ifelse(row_number() == 2,"", autocovariance),
    autocorrelation = ifelse(row_number() == 2,"", autocorrelation)
  ) %>% 
  knitr::kable(format = "html", align='ccc', escape = FALSE, width = NA) %>%
  kable_styling(full_width = FALSE, "striped") 
```

```{r}
# cov_df4 <- get_data_for_cov_table(offset = 4)
# cov_df4 %>%
#   make_cov_table_df(offset = 4) %>% 
#   display_cov_table()

offset_value <- 4
cov_df <- get_data_for_cov_table(offset = offset_value)
cov_table <- cov_df %>%
  make_cov_table_df(offset = offset_value, decimals_1st_order = 1, decimals_2nd_order = 2) 
cov_table %>%
  display_cov_table()
```

```{r}
#| echo: false

# Add rows to the table
auto_cov_cor_table <- auto_cov_cor_table %>% bind_rows(c(lag = offset_value, autocovariance = compute_cov(cov_df), autocorrelation = compute_cor(cov_df)))

# Display the table, except row 2
auto_cov_cor_table %>%
  mutate(
    autocovariance = ifelse(row_number() == 2,"", autocovariance),
    autocorrelation = ifelse(row_number() == 2,"", autocorrelation)
  ) %>% 
  knitr::kable(format = "html", align='ccc', escape = FALSE, width = NA) %>%
  kable_styling(full_width = FALSE, "striped") 
```

-   Compute c_k and r_k with a few different lag (k) values

-   Finish a partially-created correlogram with the r_k values computed



-   Show a correlogram with seasonal data with a period of one year (chocolate data?). What do the spikes tell us?
```{r}
acf(cov_df$x)$acf

values_text <- paste0("x_t <- c(",paste(cov_df$x, collapse = ", "),")")
values_text
```



## Recap (5 mins)

-   Review objectives and key points

<!-- -->

-   Formally define autocovariance, autocorrelation

-   Explain autocorrelation in time series context

::: callout-caution
## TYSON: PLEASE BUILD A SHINY APP IN WHICH STUDENTS CAN CHANGE THE AUTOCORRELATION COEFFICIENT (SLIDER FOR AUTOCORRELATION FROM 0 TO 1) AND WATCH THE GRAPH UPDATE IN REAL TIME
:::

```{r}
library(tidyverse)
library(zoo) 

# Generate data
set.seed(101) 
x <- 1:100*0.5 + arima.sim(n=100-1, list(ar=0.1, ma=0.2, order=c(1,1,1)))
e <- rnorm(100, 0, 2.5)
y <- 1:100*0.5 + e  
z <- zoo(y, order.by = 1:100)

# Create data frame  
df <- data.frame(
  time = 1:100,
  x = x,
  z = coredata(z)
)

# Plot  
ggplot(df, aes(x = time)) +
  geom_line(aes(y = x, color = "X")) + 
  geom_line(aes(y = z, color = "Z")) +
  labs(title="X vs Z Series", 
       x="Time",
       y="Values",
       color="Series") +
  theme_bw()
```

## Example Analysis (15 mins)

Walk through sample autocorrelation analysis

## Recap (20 mins)

-   Review objectives and key concepts

-   Clarify questions on autocorrelation

## Assessment:

-   Write definitions of autocovariance and autocorrelation

# Lesson 2 (60 mins): Correlograms

## Objectives:

-   Compute sample autocorrelations

-   Make and interpret correlogram plots

## Agenda:

## Introduction (5 mins)

-   Introduce correlogram plots

## Lecture (15 mins)

-   Demonstrate computing acf/pacf in R

-   Explain interpreting correlogram plots

## Hands-on Exercise (25 mins)

-   Compute acf/pacf on sample data

-   Make correlogram plots in R

-   Identify significant lags/correlations

## Recap (15 mins)

-   Review objectives and key points

-   Clarify questions on correlograms

## Assessment:

-   Compute and interpret acf/pacf on data

```{r}
#| include: false
#| eval: false

##################### THIS IS FOR CHOOSING THE SEED ##################

reps <- 5000
prodxy <- meanx <- meany <- sdx <- sdy <- covs <- cors <- rep(0,reps)
for (i in 1:reps){
  # Unset random seed
  set.seed(i)
  
# Specify means and correlation coefficient
n <- 6              # number of points
mu <- c(3, 1)       # mean vector (mu_x, mu_y)
sigma_x <- 3.5      # standard deviation x
sigma_y <- 2        # standard deviation y
rho <- -0.85          # correlation coefficient
  
  # Define variance-covariance matrix
  sigma <- matrix(
    c(sigma_x^2,
      rho*sigma_x*sigma_y,
      rho*sigma_x*sigma_y,
      sigma_y^2),
    nrow = 2)
  
  # Simulate bivariate normal data
  mvn_data_6 <- MASS::mvrnorm(n, mu, sigma) %>% 
    data.frame() %>% 
    rename(x = X1, y = X2) %>% 
    round_df(1)
  meanx[i] <- mean(mvn_data_6$x)
  meany[i] <- mean(mvn_data_6$y)
  prodxy[i] <- prod((mvn_data_6$x - meanx[i]) * (mvn_data_6$y - meany[i]))
  sdx[i] <- sd(mvn_data_6$x)
  sdy[i] <- sd(mvn_data_6$y)
  cors[i] <- cor(mvn_data_6$x, mvn_data_6$y)
  covs[i] <- cov(mvn_data_6$x, mvn_data_6$y) 
}
temp0 <- data.frame(meanx = meanx, meany = meany, sdx = sdx, sdy = sdy, cors = cors, covs = covs, prodxy = prodxy) %>% 
  mutate(i = row_number()) %>% 
  filter(meanx*10 == floor(meanx*10)) %>% 
  filter(meany*10 == floor(meany*10))  %>% 
  filter(covs*100 == floor(covs*100))  %>% 
  mutate(across(everything(), as.character)) 

View(temp0)
```

::: callout-note
Some important information....
:::

::: callout-warning
Some important information....
:::

::: callout-important
Some important information....
:::

::: callout-tip
Some important information....
:::

::: callout-caution
Some important information....
:::
