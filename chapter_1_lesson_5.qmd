---
title: "Additive and Multiplicative Models"
subtitle: "Chapter 1: Lesson 5"
format: html
editor: source
sidebar: false
---

```{r}
#| include: false
source("common_functions.R")
```

```{=html}
<script type="text/javascript">
 function showhide(id) {
    var e = document.getElementById(id);
    e.style.display = (e.style.display == 'block') ? 'none' : 'block';
 }
 
 function openTab(evt, tabName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
 }    
</script>
```

## Learning Outcomes

{{< include outcomes/chapter_1_lesson_5_outcomes.qmd >}}

## Preparation

-   Review Sections 1.5.1-1.5.3

## Learning Journal Exchange (10 min)

-   Review another student's journal
-   What would you add to your learning journal after reading your partner's?
-   What would you recommend your partner add to their learning journal?
-   Sign the Learning Journal review sheet for your peer



## Class Activity: Exploring simulated time series data (10 min)

So far, you have learned how to estimate a trend using aggregated data (i.e., an annual average) or a moving average. We will compute the seasonal effect and use this to get the random component. 

### Additive Model

The code hidden below simulates 10 years of a monthly time series with a linear trend and seasonal variation based on an additive model. Because the data are simulated, we know exactly which functions were used to create it, and we can observe what happens when we decompose this function.

```{r}
#| code-fold: true
#| code-summary: "Show the code"
#| warning: false

# Set random seed for reproducibility
set.seed(20) 

# Set parameters & initialize vectors
num_years <- 10
n <- 12 * num_years
sigma <- .75
a <- 0.05
b <- 1
c <- 0.5
trend <- seasonal <- x <- rep(0,n)
time_seq <- seq(1,n)

# Generate correlated error terms
w <- rnorm(n + 4, 0, 1)
z = w + lead(w,1) + lead(w,2) + lead(w,3) + lead(w,4)
z  = head(z, n) / 2

# Get date
year_seq <- lubridate::year(today()) - num_years  + (time_seq - 1) %/% 12
month_seq <- (time_seq - 1) %% 12 + 1
date_seq <- ymd(paste0(year_seq,"-",month_seq,"-01"))

# Get data
for (t in 1:n) {
  trend[t] <- a * t + 10
  seasonal[t] <- b * sin(t / 12 * 2 * pi * 1)  + c * cos(t / 12 * 2 * pi * 3)
  x[t] <- trend[t] + seasonal[t] + z[t]
}

x_df <- data.frame(x = x, trend = trend, seasonal = seasonal)

start_year <- lubridate::year(today()) - num_years
start_date <- lubridate::ymd(paste0(start_year,"-01-01"))

# start_date <- lubridate::ymd("1958-01-01")
date_seq <- seq(start_date,
    start_date + months(nrow(x_df)-1),
    by = "1 months")

x_df_ts <- x_df |>
  mutate(
    date = date_seq,
    month = tsibble::yearmonth(date)
  ) |>
  select(date, month, trend, seasonal, x) |>
  as_tsibble(index = month)
```

```{r}
#| echo: false

x_df_ts |>
  display_partial_table(6,2)
```



The code above has generated simulated data, where the trend is linear with equation

$$
  m_t = \frac{t}{20}
$$

and the seasonal effect follows the function

$$
  s_t = \sin \left( \frac{t\pi}{6} \right) + \frac{1}{2}\cos\left(\frac{t \pi}{18} \right) + 5
$$

Letting $t$ represent the month number across 10 years, we simulate a time series. Click on the tabs below to compare the actual construction of the time series (using the components generated in the code above) to the decomposition in R.

::: panel-tabset
#### Actual Construction (Additive)

Here is a plot of the components of the simulated data.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

trend_plot <- ggplot(x_df_ts, aes(x=month, y=trend)) + 
  geom_line() +
  labs(
    title="Plot of Trend", 
    x="Month", 
    y="Trend"
    ) +
  theme(plot.title = element_text(hjust = 0.5))

seasonal_plot <- ggplot(x_df_ts, aes(x=month, y=seasonal)) + 
  geom_line() +
  labs(
    title="Plot of Seasonal Effect", 
    x="Month", 
    y="Seasonal"
    ) +
  theme(plot.title = element_text(hjust = 0.5))

error_plot <- ggplot(x_df_ts, aes(x = month, y = x - trend - seasonal)) + 
  geom_line() +
  labs(
    title="Plot of Random Error Term", 
    x="Month", 
    y="Random"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

x_plot <- ggplot(x_df_ts, aes(x=month, y=x)) + 
  geom_line() +
  labs(
    title="Plot of Simulated Time Series", 
    x="Month", 
    y="x"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

x_plot <- x_plot  + labs(title = "True (Simulated) Values", x = NULL)
trend_plot <- trend_plot + labs(title = NULL, x = NULL)
seasonal_plot <- seasonal_plot + labs(title = NULL, x = NULL)
error_plot <- error_plot + labs(title = NULL)

x_plot / trend_plot / seasonal_plot / error_plot 
```

#### Decomposition (Additive)

Now, we use R to decompose the time series $\{x_t\}$.

```{r}
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

x_decompose <- x_df_ts |>
    model(feasts::classical_decomposition(x,
        type = "add"))  |>
    components()

autoplot(x_decompose)
```

```{r}
#| include: false
i <- c(0:n)
# a <- 0
x <- a*i + b*sin(i/12*2*pi) + c*cos(i/12*2*pi*3)

df <- data.frame(i, x)

ggplot(df, aes(x=i, y=x)) + 
  geom_line() +
  labs(title="Plot of Function", 
       x="i", 
       y="x")
```
:::  
<!-- End of panel-tabset -->

::: {.callout-tip icon="false" title="Check Your Understanding"}
-   How does the (estimated) decomposition compare to the theoretical values above?
    -   How well is the trend estimated?
    -   How well is the seasonal effect estimated?
    -   How well is the random effect estimated?
-   Make changes to the simulated data and observe the effect on the plots
:::

### Multiplicative Model

We use the same simulated data as before, but this time we apply R's multiplicative model. This implies that the error term, $z_t$, has a mean of 1, rather than 0.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Set random seed for reproducibility
set.seed(123) 

# Set parameters & initialize vectors
num_years <- 10
n <- 12 * num_years
sigma <- .75
a <- 0.03
b <- 1
c <- 0.5 
trend <- seasonal <- x <- rep(0,n)
time_seq <- seq(1,n)

# Generate correlated error terms
w <- rnorm(n + 4, 0.2, 0.1) # Changed to a mean of 1 and sd of 0.03
z = w + lead(w,1) + lead(w,2) + lead(w,3) + lead(w,4)
z  = head(z, n)

# Get date
year_seq <- lubridate::year(today()) - num_years  + (time_seq - 1) %/% 12
month_seq <- (time_seq - 1) %% 12 + 1
date_seq <- ymd(paste0(year_seq,"-",month_seq,"-01"))

# Get data
for (t in 1:n) {
  trend[t] <- exp(a * t)
  seasonal[t] <- b * sin(t / 12 * 2 * pi * 1)  + c * cos(t / 12 * 2 * pi * 3) + 5
  x[t] <- trend[t] * seasonal[t] * z[t] # Note R's definition of the mult. model
}

x_df <- data.frame(x = x, trend = trend, seasonal = seasonal)

start_year <- lubridate::year(today()) - num_years
start_date <- lubridate::ymd(paste0(start_year,"-01-01"))

# start_date <- lubridate::ymd("1958-01-01")
date_seq <- seq(start_date,
    start_date + months(nrow(x_df)-1),
    by = "1 months")

x_df_ts <- x_df |>
  mutate(
    date = date_seq,
    month = tsibble::yearmonth(date)
  ) |>
  select(date, month, trend, seasonal, x) |>
  as_tsibble(index = month)
```

```{r}
#| echo: false

x_df_ts |>
  display_partial_table(6,2)
```

The code above simulated data, where the trend is exponential with equation

$$
  m_t = e^{0.03 t}
$$

and the seasonal effect follows the function

$$
  s_t = \sin \left( \frac{t\pi}{6} \right) + \frac{1}{2}\cos\left(\frac{t \pi}{18} \right) + 5
$$

Letting $t$ represent the month number across 10 years, we simulate a time series with multiplicative effects. Click on the tabs below to compare the actual construction of the time series (using the components generated in the code above) to the decomposition in R.

::: panel-tabset
#### Actual Construction (Multiplicative)

Here is a plot of the components of the simulated data.

```{r}
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

trend_plot <- ggplot(x_df_ts, aes(x=month, y=trend)) + 
  geom_line() +
  labs(
    title="Plot of Trend", 
    x="Month", 
    y="Trend"
    ) +
  theme(plot.title = element_text(hjust = 0.5))

seasonal_plot <- ggplot(x_df_ts, aes(x=month, y=seasonal)) + 
  geom_line() +
  labs(
    title="Plot of Seasonal Effect", 
    x="Month", 
    y="Seasonal"
    ) +
  theme(plot.title = element_text(hjust = 0.5))

error_plot <- ggplot(x_df_ts, aes(x = month, y = x / trend / seasonal)) + 
  geom_line() +
  labs(
    title="Plot of Random Error Term", 
    x="Month", 
    y="Random"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

x_plot <- ggplot(x_df_ts, aes(x=month, y=x)) + 
  geom_line() +
  labs(
    title="Plot of Simulated Time Series", 
    x="Month", 
    y="x"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

x_plot <- x_plot  + labs(title = "True (Simulated) Values", x = NULL)
trend_plot <- trend_plot + labs(title = NULL, x = NULL)
seasonal_plot <- seasonal_plot + labs(title = NULL, x = NULL)
error_plot <- error_plot + labs(title = NULL)

x_plot / trend_plot / seasonal_plot / error_plot 
```

#### Decomposition (Multiplicative)

Now, we use R to decompose the time series $\{x_t\}$.

```{r}
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

x_decompose <- x_df_ts |>
    model(feasts::classical_decomposition(x,
        type = "add"))  |>
    components()

autoplot(x_decompose)
```

```{r}
#| include: false
i <- c(0:n)
# a <- 0
x <- a*i + b*sin(i/12*2*pi) + c*cos(i/12*2*pi*3)

df <- data.frame(i, x)

ggplot(df, aes(x=i, y=x)) + 
  geom_line() +
  labs(title="Plot of Function", 
       x="i", 
       y="x")
```
:::  
<!-- End of panel-tabset -->


::: {.callout-tip icon="false" title="Check Your Understanding"}

-   How does the (estimated) decomposition compare to the theoretical values above?
    -   How well is the trend estimated?
    -   How well is the seasonal effect estimated?
    -   How well is the random effect estimated?
-   Make changes to the simulated data and observe the effect on the plots

:::




### Additive and Multiplicative Models in the Textbook and R

Both the textbook and R use the same model in the additive case:

$$
  x_t = m_t + s_t + z_t
$$

However, there is a discrepancy in the definitions for the mulitplicative models. The textbook defines the multiplicative model as

$$
  x_t = m_t \cdot s_t + z_t
$$ but R defines the multiplicative model as

$$
  x_t = m_t \cdot s_t \cdot z_t
$$ You can investigate R's definition by executing this command in RStudio.

```{r}
#| eval: false

?classical_decomposition
```




### Which Model Should I Use? Additive or Multiplicative?

Compare the following two time series.

```{r}
#| echo: false

# Read and clean rexburg weather data
weather_dat <- rio::import("https://byuistats.github.io/timeseries/data/rexburg_weather.csv")

w2 <- weather_dat |>
  dplyr::select("NAME", "DAY", "MONTH", "YEAR", "DATE", "TMAX") |>
  pivot_wider(names_from = "NAME", values_from = c("TMAX")) |>
  rename(
    "byui" = "REXBURG BYU IDAHO, ID US",
    "airport" = "REXBURG MADISON CO AIRPORT, ID US",
    "moody" = "MOODY IDAHO, ID US"
  )

w3 <- w2 |>
  dplyr::select(byui, airport) |>
  rename(x = byui, y = airport) |>
  filter(abs(x - y)<50)
# plot(w3$x, w3$y)
lm_byu <- lm(y~x, data= w3)

w4 <- w2 |>
  dplyr::select(moody, airport) |>
  rename(x = moody, y = airport) |>
  filter(abs(x - y)<50)
# plot(w4$x, w4$y)
lm_moody <- lm(y~x, data= w4)

weather_clean <- w2 |>
  mutate(byui_pred = predict(lm_byu, data.frame(x=w2$byui))) |>
  mutate(moody_pred = predict(lm_moody, data.frame(x=w2$moody))) |>
  mutate(rexburg = airport) |>
  mutate(rexburg =
           case_when(
             airport > 100 ~ byui_pred,
             !is.na(airport) ~ airport,
             !is.na(byui_pred) ~ byui_pred,
             !is.na(moody_pred) ~ moody_pred,
             TRUE ~ NA
           )
        ) |>
  mutate(imputed = !(rexburg == round(rexburg, 0))) |>
  mutate(rexburg = round(rexburg, 0)) |>
  mutate(dates = mdy(DATE)) |>
  filter(dates > mdy("08/31/1998")) |>
  filter(!is.na(rexburg)) |>
  rename(rexburg_airport_high = rexburg) |>
  dplyr::select(dates, rexburg_airport_high, imputed) |>
  filter(dates > mdy("01/01/1999"))

# weather_clean |>
#   mutate(years = year(dates)) |>
#   group_by(years) |>
#   summarize(average = mean(rexburg_airport_high)) |>
#   plot

rexburg_day <- weather_clean |>
  mutate(date_seq = dates) |>
  mutate(
  dates = date_seq,
  year = lubridate::year(date_seq),
  month = lubridate::month(date_seq),
  value = rexburg_airport_high
  ) |>
  dplyr::select(-date_seq, -imputed) |>
  tibble()

rexburg_daily_ts <- rexburg_day |>
  mutate(index = dates) |>
  as_tsibble(index = index)

rexburg_annual_ts <- summarise(index_by(rexburg_daily_ts, year), value = mean(value))

rexburg_weather_plot <- autoplot(rexburg_daily_ts, .vars = value) +
  labs(
    x = "Date",
    y = "High Temp (F)",
    title = "Daily High Temperature in Rexburg, Idaho"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

# mp <- autoplot(rexburg_daily_ts, .vars = value) +
#   labs(y = "high temperature")
# yp <- autoplot(rexburg_annual_ts) +
#   labs(y = "high temperature")
# # +
# #   scale_x_continuous(breaks = seq(1900, 2010, by = 2))
# mp / yp



##################### S&P 500

replaceCommas<-function(x){
  x<-as.numeric(gsub("\\,", "", x))
}

sp500_dat <- rio::import("https://byuistats.github.io/timeseries/data/sp500.csv") |>
  mutate(dates = mdy(Date))

sp500_day <- sp500_dat |>
  mutate(date_seq = dates) |>
  mutate(
    dates = date_seq,
    year = lubridate::year(date_seq),
    month = lubridate::month(date_seq),
    value = replaceCommas(Close)
  ) |>
  dplyr::select(-date_seq) |>
  tibble()

sp500_ts <- sp500_day |>
  mutate(index = dates) |>
  as_tsibble(index = index)

# sp500_annual_ts <- summarise(index_by(sp500_ts, year), value = mean(value))
# 
# temp <- sp500_ts |> filter(month == 7 & day(dates) == 1) |> 
#   select(Date, year) 
# 
# temp2 <- sp500_annual_ts |> 
#   right_join(temp)

sp500_plot <- autoplot(sp500_ts, .vars = value) +
  labs(
    x = "Date",
    y = "Closing Price",
    title = "Daily Closing Price of the S&P 500 Stock Index"
  )  +
  theme(plot.title = element_text(hjust = 0.5))


rexburg_weather_plot / sp500_plot
```

::: {.callout-tip icon="false" title="Check Your Understanding"}
Complete a table like the following in your Learning Journal to compare characteristics of these two time series. Be sure to include a sketch of the respective time plots.

|                                          | Rexburg Temperature | S&P 500 Closing Price |
|------------------------------------------|---------------------|-----------------------|
| Deterministic or stochastic trend?       |                     |                       |
| Is there a seasonal effect?              |                     |                       |
| Is there evidence of cycles?             |                     |                       |
| Does the variation get bigger over time? |                     |                       |
| Additive or multiplicative model?        |                     |                       |
:::

<!-- ## POSSIBLY: DEMONSTRATE THAT TWO UNRELATED TIME SERIES WILL BE CORRELATED IF THEY BOTH CONTAIN A TREND---------- -->

<!-- Compare Rexburg weather and Basel, Switzerland Weather. (Better yet, Melbourne, Austrailia) -->





## Small Group Activity: Decomposition of Baltimore Crime Data (20 min)

### Background 

The City of Baltimore publishes crime data, which can be accessed through a query. 
This dataset is sourced from the City of Baltimore Open Data and is updated monthly. 
You can explore the data on [data.world](https://data.world/data-society/city-of-baltimore-crime-data).

Use the following code to import the data:


<!-- **Packages** -->
<!-- ```{r, warning=FALSE} -->
<!-- # library(dplyr) -->
<!-- # library(tidyr) -->
<!-- # library(ggplot2) -->
<!-- # library(tidyverse) -->
<!-- # library(dygraphs) -->
<!-- # library(tidyquant) -->
<!-- # library(forecast) -->
<!-- ``` -->



```{r}
#| code-fold: true
#| code-summary: "Show the code"

if (!require("pacman")) install.packages("pacman")
pacman::p_load("tsibble", "fable",
               "feasts", "tsibbledata",
               "fable.prophet", "tidyverse",
               "patchwork", "rio")

crime_df <- read.csv("https://query.data.world/s/gibquqj7violcatsd74xyyg7r4fwxp?dws=00000", header=TRUE, stringsAsFactors=FALSE)
```


```{r}
#| include: false
#| eval: false
# # Store the data, in case the query stops working
# rio::export(crime_df, "data/baltimore_crime.csv")
```


The data set consists of `r nrow(crime_df)` rows and `r ncol(crime_df)` columns. 
There are a few key variables:

- **Date and Time:** Records the date and time of each incident.
- **Location:** Detailed coordinates of each incident.
- **Crime Type:** Description of the type of crime.

When exploring a new time series, it is crucial to carefully examine the data. Here are a few rows of the original data set. 

```{r}
#| echo: false

# View data
crime_df |> 
  display_partial_table(6,1)
```


<!-- Check Your Understanding -->

::: {.callout-tip icon=false title="Check Your Understanding"}

-   Using the command `crime_df |> summary()`, we learn that the `Total.Incidents` always equals 1. What does each row in the data frame represent?

:::

```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Data Summary and Aggregation
# Group by dates column and summarize from Total.Incidents column
daily_summary_df <- crime_df |>
  rename(dates = CrimeDate) |>
  group_by(dates) |>
  summarise(incidents = sum(Total.Incidents))


# Data Transformation and Formatting
# Select relevant columns, format dates, and arrange the data
crime_data <- daily_summary_df |>
  select(dates, incidents) |>
  mutate(dates = mdy(dates)) |>
  mutate(
    month = month(dates),
    day = day(dates),
    year = year(dates)
  ) |>
  select(dates, month, day, year, incidents) |>
  arrange(dates)

# Convert formatted data to a tsibble with dates as the index
crime_tsibble <- as_tsibble(crime_data, index = dates)
```

Here are a few rows of the summarized data.

```{r}
#| echo: false

# View data
daily_summary_df |>
  display_partial_table(6,3) 
```

The following table summarizes the number of days in each month for which crime data were reported.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

crime_data |>
  mutate(month_char = format(as.Date(dates), '%b') ) |>
  group_by(month, month_char, year) |>
  summarise(n = n(), .groups = "keep") |>
  group_by() |>
  arrange(year, month) |>
  select(-month) |>
  rename(Year = year) |>
  pivot_wider(names_from = month_char, values_from = n) |>
  display_table()
```


<!-- Check Your Understanding -->

::: {.callout-tip icon=false title="Check Your Understanding"}

-   What do you observe about the data?
-   What are some problems that could arise from incomplete data?
-   How do you recommend we address the missing data?

:::

Here is a time plot of the number of crimes reported in Baltimore daily.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Time series plot of total incidents over time
crime_plot <- autoplot(crime_tsibble, .vars = incidents) +
  labs(
    x = "Time",
    y = "Total Incidents",
    title = "Total Incidents Over Time"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

# Display the plot
crime_plot
```

<!-- Check Your Understanding -->

::: {.callout-tip icon=false title="Check Your Understanding"}

-   What do you notice about this time plot?
    - Describe the trend
    - Is there evidence of seasonality?
    - Is the additive or multiplicative model appropriate?
    - Which date has the highest number of recorded crimes? Can you determine a reason for this spike?

:::

### Monthly Summary

We could analyze the data at the daily level, but for simplicity we will model the monthly totals.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

crime_monthly_ts <- crime_tsibble |>
  index_by(month_year = floor_date(as_date(dates), "month")) |>
  summarise(value = sum(incidents))

# Plot mean annual total incidents using autoplot
autoplot(crime_monthly_ts, .vars = value) +
  labs(
    x = "Year",
    y = "Total Monthly Incidents",
    title = "Total Monthly Incidents"
  ) +
  theme(plot.title = element_text(hjust = 0.5))
```

There is incomplete data for `r temp <- crime_tsibble |> arrange(dates) |> as.data.frame() |> tail(1); temp |> select(year) |> pull()`, as data were not provided after `r last_date <- temp |> select(dates) |> pull(); paste0(month(last_date), "/", day(last_date), "/", year(last_date))`. We will only consider data through `r month(paste0(month(last_date)-1, "/1/", year(last_date)), label = TRUE, abbr = FALSE)` `r ifelse(month(last_date) == 1, year(last_date)-1, year(last_date))`.
<!-- ~ -->
<!-- This is hard-coded.. -->
We will omit any data after October 2016.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

crime_monthly_ts <- crime_monthly_ts |>
  filter(month_year < mdy("10/31/2016"))
```


### Moving Average

We can use the following function to compute the moving average

```{r}
# compute moving average
compute_moving_average <- function(df, variable, periods = 12) {
  sum <- 0
  
  for (i in 1:(periods / 2)) {
    sum <- sum + lead(eval(substitute(variable), df), i)           # x_{t+i}
    sum <- sum + lag(eval(substitute(variable), df), i)            # x_{t-i}
  }

  sum <- sum + eval(substitute(variable), df)
  sum <- sum - lag(eval(substitute(variable), df), periods / 2) / 2
  sum <- sum - lead(eval(substitute(variable), df), periods / 2) / 2

  df$m_hat <- sum / periods

  return(df)
}

crime_decomposition <- crime_monthly_ts |>
  compute_moving_average(value)
```

Here are the first few rows of this new file. 
```{r}
#| echo: false

crime_decomposition |>
  head(13) |>
  display_table()
```

### Estimated Monthly Additive Effect

<!-- Check Your Understanding -->

::: {.callout-tip icon=false title="Check Your Understanding"}

-   Use the 12-month centered moving average computed above to calculate the estimated monthly additive effect.
-   Question1
-   Question2

:::
































# DONE TO HERE


**Calculate Mean Annual Total Incidents**

```{r}
# Calculate mean annual total incidents
crime_annual_ts <- crime_tsibble |>
  index_by(year = year(dates)) |>
  summarise(value = mean(incidents))

# Plot mean annual total incidents using autoplot
autoplot(crime_annual_ts, .vars = value) +
  labs(
    x = "Year",
    y = "Mean Daily Incidents",
    title = "Mean Daily Incidents"
  ) +
  theme(plot.title = element_text(hjust = 0.5))
```


**Monthly Boxplots of Total Incidents**

```{r}
# Create boxplots
ggplot(crime_tsibble, aes(x = month, y = incidents)) +
  geom_boxplot() +
  labs(
    x = "Month",
    y = "Total Incidents",
    title = "Boxplots of Total Incidents by Month"
  ) +
  theme(plot.title = element_text(hjust = 0.5))
```



## Estimating the Trend: Moving Average (5 min)

```{r}
# Create a daily plot
dp <- autoplot(crime_tsibble, .vars = incidents) +
    labs(
      x = "Month",
      y = "Total Incidents",
      title = "Total Incidents Over Time"
    ) +
    theme(plot.title = element_text(hjust = 0.5))

  # Calculate mean monthly total incidents
  mean_monthly_incidents <- crime_tsibble |>
    as.data.frame() |>
    group_by(year, month) |>
    summarize(value = mean(incidents)) |>
  mutate(index = tsibble::yearmonth( mdy(paste0(month, "/15/", year)) )) |>
  as_tsibble(index = index)

  # Calculate mean annual total incidents
  mean_annual_incidents <- crime_tsibble |>
    as.data.frame() |>
    group_by(year) |>
    summarize(value = mean(incidents)) |>
  mutate(index = tsibble::yearmonth( mdy(paste0("7/1/",year)) )) |>
  as_tsibble(index = index)
```


```{r}
# Create a yearly plot
  yp <- ggplot(mean_annual_incidents, aes(x = year, y = value)) +
    geom_line() +
    labs(
      x = "Year",
      y = "Mean Total Crime Incidents",
      title = "Annual Mean Total Crime Incidents"
    ) +
    scale_x_continuous(breaks = seq(2004, max(crime_tsibble$year), by = 2)) +
    theme(plot.title = element_text(hjust = 0.5))

# Create a monthly plot
  mp <- ggplot(mean_monthly_incidents, aes(x = index, y = value)) +
    geom_line() +
    labs(
      x = "Year",
      y = "Mean Total Crime Incidents",
      title = "Monthly Mean Total Crime Incidents"
    ) +
    # scale_x_continuous(breaks = seq(2004, max(crime_tsibble$year), by = 2)) +
    theme(plot.title = element_text(hjust = 0.5))

  # Display both simultaneously
  dp / mp
  dp / yp

```





















## STARTING HERE

```{r}
#| include: false

# load packages
if (!require("pacman")) install.packages("pacman")
pacman::p_load("tsibble", "fable",
               "feasts", "tsibbledata",
               "fable.prophet", "tidyverse",
               "patchwork", "rio")

# read in the data from a csv
chocolate_month <- rio::import("https://byuistats.github.io/timeseries/data/chocolate.csv")
start_date <- lubridate::ymd("2004-01-01")  
date_seq <- seq(start_date,
                start_date + months(nrow(chocolate_month)-1),
                by = "1 months")

# create a tibble including variables dates, year, month, value
chocolate_tibble <- tibble(
  dates = date_seq,
  year = lubridate::year(date_seq),
  month = lubridate::month(date_seq),
  value = pull(chocolate_month, chocolate)
)

# create a tsibble where the index variable is the year/month
chocolate_month_ts <- chocolate_tibble |>
  mutate(index = tsibble::yearmonth(dates)) |>
  as_tsibble(index = index)

# generate the ts plot
choc_plot <- autoplot(chocolate_month_ts, .vars = value) +
  labs(
    x = "Month",
    y = "Searches",
    title = "Relative Number of Google Searches for 'Chocolate'"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

```





## Estimating the Trend: Moving Average (5 min)

```{r}
#| code-fold: true
#| code-summary: "Show the code"
#| warning: false

# Computes the moving average of values in a time series
compute_moving_average <- function(df, variable, periods = 12) {
  sum <- 0

  for (i in 1:(periods / 2)) {
    sum <- sum + lead(eval(substitute(variable), df), i)           # x_{t+i}
    sum <- sum + lag(eval(substitute(variable), df), i)            # x_{t-i}
  }
  sum <- sum + eval(substitute(variable), df)
  sum <- sum - lag(eval(substitute(variable), df), periods / 2) / 2
  sum <- sum - lead(eval(substitute(variable), df), periods / 2) / 2
  df$m_hat <- sum / periods
  return(df)
}

chocolate_annual_ts <- summarise(
    index_by(chocolate_month_ts, year), 
    value = mean(value)
  ) |>
  mutate(index = tsibble::yearmonth( mdy(paste0("7/1/",year)) )) |>
  as_tsibble(index = index)

# monthly plot
mp <- autoplot(chocolate_month_ts, .vars = value) +
  geom_line(data = chocolate_annual_ts, 
            aes(x = index, y = value), 
            color = "#56B4E9") +
  geom_line(data = chocolate_month_ts |> compute_moving_average(value), 
            aes(x = index, y = m_hat), 
            color = "#E69F00") +
  labs(
    x = "Month",
    y = "Searches",
    title = "Relative Number of Google Searches for 'Chocolate'"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

mp
```

The blue line illustrates the mean of all the values for each year, plotted at July 1 for each of the respective years. The orange line is the moving average computed using Equation (1.6).



## Estimating the Trend: Moving Average (5 min)

```{r}
#| code-fold: true
#| code-summary: "Show the code"
#| warning: false

# Computes the moving average of values in a time series
compute_moving_average <- function(df, variable, periods = 12) {
  sum <- 0

  for (i in 1:(periods / 2)) {
    sum <- sum + lead(eval(substitute(variable), df), i)           # x_{t+i}
    sum <- sum + lag(eval(substitute(variable), df), i)            # x_{t-i}
  }
  sum <- sum + eval(substitute(variable), df)
  sum <- sum - lag(eval(substitute(variable), df), periods / 2) / 2
  sum <- sum - lead(eval(substitute(variable), df), periods / 2) / 2
  df$m_hat <- sum / periods
  return(df)
}

chocolate_annual_ts <- summarise(
    index_by(chocolate_month_ts, year), 
    value = mean(value)
  ) |>
  mutate(index = tsibble::yearmonth( mdy(paste0("7/1/",year)) )) |>
  as_tsibble(index = index)

# monthly plot
mp <- autoplot(chocolate_month_ts, .vars = value) +
  geom_line(data = chocolate_annual_ts, 
            aes(x = index, y = value), 
            color = "#56B4E9") +
  geom_line(data = chocolate_month_ts |> compute_moving_average(value), 
            aes(x = index, y = m_hat), 
            color = "#E69F00") +
  labs(
    x = "Month",
    y = "Searches",
    title = "Relative Number of Google Searches for 'Chocolate'"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

mp
```

The blue line illustrates the mean of all the values for each year, plotted at July 1 for each of the respective years. The orange line is the moving average computed using Equation (1.6).










































### Aggregate to the annual level

To help visualize what is happening with a time series, we often aggregate the data in the time series to the annual level. This can make it easier to spot a trend. The first plot is the time series plot of the raw data, and the second plot is a time series plot of the annual means.

```{r}
chocolate_annual_ts <- summarise(index_by(chocolate_month_ts, year), value = mean(value))

# monthly plot
mp <- autoplot(chocolate_month_ts, .vars = value) +
  labs(
    x = "Month",
    y = "Searches",
    title = "Relative Number of Google Searches for 'Chocolate'"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

# yearly plot
yp <- autoplot(chocolate_annual_ts, .vars = value) +
  labs(
    x = "Year",
    y = "Searches",
    title = "Mean Annual Google Searches for 'Chocolate'"
  ) +
  scale_x_continuous(breaks = seq(2004, max(chocolate_month_ts$year), by = 2)) +
  theme(plot.title = element_text(hjust = 0.5))

# display both simultaneously
mp / yp
```

::: {.callout-tip icon="false" title="Check Your Understanding"}
-   What do you observe in the trend?
-   What do you suspect is causing this trend?
:::

















## When to use additive vs. multiplicative decomposition (5 min)

<!-- -   Additive: Constant variance -->
<!-- -   Multiplicative: Variance grows with the value of the time series -->

## Additive Decomposition

The additive model for a time series, $\{x_t\}$, is:

$$
  x_t = m_t + s_t + z_t
$$

where $x_t$ is the observed series, $m_t$ is the trend, $s_t$ is the seasonal effect, $z_t$ is random variation, and $t = 1, 2, 3, \ldots, n$. We consider $z_t$ as a sequence of correlated random variables with mean 0.

The residual is the part of the time series that is not explained by the trend or the seasonal effect. This is an estimate of \$ For an additive model, the residual is computed as: $$
  Residual = Value - Trend - Seasonal
$$

The code below produces a plot showing the original data in the time series, the trend, the seasonal effect, and the residual (random component).

```{r}
#| warning: false

choc_decompose <- chocolate_month_ts |>
    model(feasts::classical_decomposition(value,
        type = "add"))  |>
    components()

autoplot(choc_decompose)
```

::: {.callout-tip icon="false" title="Check Your Understanding"}
-   How does the trend and seasonality compare to the plots made previously?
-   What do you observe in the residual?
    -   Are there any unusual spikes? Use Google to try to determine what may have caused the usual spikes.
:::

## Recap (5 min)

-   Review objectives and key concepts
-   Clarify questions





## Homework

::: {.callout-note icon="false"}
## Download Assignment

<!-- ## need to update href link to correct files when we get them -->

<a href="https://byuistats.github.io/timeseries/homework/homework_1_5.qmd" download="homework_1_5.qmd"> homework_1_5.qmd </a>
:::






<a href="javascript:showhide('Solutions1')"
style="font-size:.8em;">Balitmore Crime Time Plot</a>

::: {#Solutions1 style="display:none;"}

```{r}
# Dates with high criminal activity
crime_data |> arrange(desc(incidents)) |> head()
```

On April 27, 2015, 419 crimes were recorded. These are associated with protests over arrest of Freddie Gray.
:::






<a href="javascript:showhide('Solutions2')"
style="font-size:.8em;">Which Model? & Matching Solutions</a>

::: {#Solutions2 style="display:none;"}

:::








<a href="javascript:showhide('Solutions3')"
style="font-size:.8em;">Which Model? & Matching Solutions</a>

::: {#Solutions3 style="display:none;"}

:::
